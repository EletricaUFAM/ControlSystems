          ====================================================
                         HP48G Entry Reference
                      Compact listing for Debug4x
             EDB version 1.13, Wed Dec 11 10:25:31 CET 2002
          ====================================================
                           by Carsten Dominik
                         dominik@science.uva.nl

!!append$?                         ( $ $' -> $+$' )
!!append$                          ( $ $' -> $+$' )
!!insert$                          ( $ $' -> $'+$ )
!*triand                           ( T T ->              )
                                   ( F T -> F T <SEMI>   )
!*trior                            (   F -> <SKIP>   )
                                   ( T T -> <COLA>   )
(!AND$)                            ( $ $' -> $''   ??? )
!append$                           ( $ $' -> $+$' )
!append$SWAP                       ( ob $ $' -> $+$' ob )
(!CHANGETYPE)                      ( ob #prolog -> ob' )
!DcompWidth                        ( # ->  )
!insert$                           ( $ $' -> $'+$ )
(!MAKEHXS)                         ( #nibs -> hxs )
(!NOT$)                            ( $ $' -> $''   ??? )
(!OR$)                             ( $ $' -> $''   ??? )
(!TurnOff)                         (  ->  )
(!XOR$)                            ( $ $' -> $''   ??? )
#*                                 ( # #' -> #*#' )
#*OVF                              ( # #' -> #*#' )
#+                                 ( # #' -> #+#' )
#+-1                               ( # #' -> #+#'-1 )
#+DUP                              ( # #' -> #+#' #+#' )
#+OVER                             ( ob # #' -> ob #+#' ob )
(#+OVF)                            ( # #' -> #+#' )
#+PICK                             ( 1..n+m #n #m -> 1..n+m 1 )
#+ROLL                             ( 1..n+m #n #m -> 2..n+m 1 )
#+SWAP                             ( ob # #' -> #+#' ob )
#+UNROLL                           ( 1..n+m #n #m -> n+m 1..n+m-1 )
#-                                 ( # #' -> #-#' )
#-#2/                              ( # #' -> (#-#')/2 )
#-+1                               ( # #' -> #-#'+1 )
#-DUP                              ( # #' -> #-#' #-#' )
#-OVER                             ( ob # #' -> ob #-#' ob )
#-PICK                             ( 1..n-m #n #m -> 1..n-m 1 )
#-ROLL                             ( 1..n-m #n #m -> 2..n-m 1 )
#-SWAP                             ( ob # #' -> #-#' ob )
#-UNROLL                           ( 1..n-m #n #m -> n-m 1..n+m-1 )
#/                                 ( # #' -> #r #q )
#0<>                               ( # -> flag )
#0=                                ( # -> flag )
#0=?SEMI                           ( #0 -> :: ;              )
                                   (  # -> :: <ob1> <rest> ; )
#0=?SKIP                           ( #0 -> :: <ob2> <rest> ; )
                                   (  # -> :: <ob1> <rest> ; )
#0=case                            ( #0 -> :: <ob1> ;        )
                                   (  # -> :: <ob2> <rest> ; )
#0=ITE                             ( #0 -> :: <ob1> <ob3> <rest> ; )
                                   (  # -> :: <ob2> <rest>         )
#0=UNTIL                           ( # -> # )
#1+                                ( # -> #+1 )
#1+'                               ( # -> #+1 nob )
#1+_ONE_DO                         ( #stop ->  )
#1+DUP                             ( # -> #+1 #+1 )
#1+LAST$                           ( $ #start-#1 -> $' )
#1+NDROP                           ( ob meta ->  )
#1+NDROP                           ( ob 1..n #n ->  )
#1+PICK                            ( 1..n #n-1 -> 1..n 1 )
#1+ROLL                            ( ob 1..n #n -> 1..n ob )
#1+ROT                             ( ob ob' # -> ob' #+1 ob )
#1+SWAP                            ( ob # -> #+1 ob )
#1+UNROLL                          ( ob 1..n #n -> n ob 1..n-1 )
#1-                                ( # -> #-1 )
#1-+                               ( # #' -> #+#'-1 )
#1--                               ( # #' -> #-#'+1 )
#1-1SWAP                           ( # -> 1 #-1 )
#1-DUP                             ( # -> #-1 #-1 )
#1-ROT                             ( ob ob' # -> ob' #-1 ob )
#1-SUB$                            ( $ #start #end+#1 -> $' )
#1-SWAP                            ( meta&ob -> meta ob )
#1-SWAP                            ( meta&ob -> meta ob )
#1-UNROT                           ( ob ob' # -> #-1 ob ob' )
#1-{}N                             ( ob1..obn #n+1 -> {} )
#10*                               ( # -> #*10 )
#10+                               ( # -> #+10 )
#12+                               ( # -> #+12 )
(#132)                             306d 132h
(#134)                             308d 134h
(#135)                             309d 135h
(#136)                             310d 136h
(#137)                             311d 137h
(#138)                             312d 138h
(#139)                             313d 139h
(#13A)                             314d 13Ah
(#13B)                             315d 13Bh
(#13D)                             317d 13Dh
#1<>                               ( # -> flag )
#1=                                ( # -> flag )
#1=?SKIP                           ( #1 -> :: <ob2> <rest> ; )
                                   (  # -> :: <ob1> <rest> ; )
#1=case                            ( #1 -> :: <ob1> ;        )
                                   (  # -> :: <ob2> <rest> ; )
#2*                                ( # -> #*2 )
#2+                                ( # -> #+2 )
#2+PICK                            ( 1..n #n-2 -> 1..n 1 )
#2+ROLL                            ( a b 1..n #n -> b 1..n a )
#2+UNROLL                          ( a b 1..n #n -> n a b 1..n-1 )
#2-                                ( # -> #-2 )
#2/                                ( # -> #/2 )
#2<>                               ( # -> flag )
#2=                                ( # -> flag )
#3+                                ( # -> #+3 )
#3+PICK                            ( 1..n #n-3 -> 1..n 1 )
#3-                                ( # -> #-3 )
#3=                                ( # -> flag )
#4+                                ( # -> #+4 )
#4+PICK                            ( 1..n #n-4 -> 1..n 1 )
#4-                                ( # -> #-4 )
#5+                                ( # -> #+5 )
#5-                                ( # -> #-5 )
#5=                                ( # -> flag )
#6*                                ( # -> #*6 )
#6+                                ( # -> #+6 )
#6-                                ( # -> #-6 )
#7+                                ( # -> #+7 )
#8*                                ( # -> #*8 )
#8+                                ( # -> #+8 )
(#8F)                              143d 8Fh
#9+                                ( # -> #+9 )
#:>$                               ( # -> "#: " )
#<                                 ( # #' -> flag )
#<3                                ( # -> flag )
#<>                                ( # #' -> flag )
#<>case                            ( #m #n -> :: <ob2> <rest> ; )
                                   ( #m #n -> :: <ob1> ;        )
#<case                             ( #m #n -> :: <ob1> ;        )
                                   ( #m #n -> :: <ob2> <rest> ; )
#<ITE                              ( #m #n -> :: <ob1> <ob3> <rest> ; )
                                   ( #m #n -> :: <ob2> <rest> ;       )
#=                                 ( # #' -> flag )
#=?SKIP                            ( #m #n -> :: <ob2> <rest> ; )
                                   ( #m #n -> :: <ob1> <rest> ; )
#=case                             ( #m #n -> :: <ob1> ;        )
                                   ( #m #n -> :: <ob2> <rest> ; )
#=casedrop                         ( #m #n -> :: <ob1> ;           )
                                   ( #m #n -> :: #m <ob2> <rest> ; )
#=casedrpfls                       ( #m #n -> F                    )
                                   ( #m #n -> :: #m <ob1> <rest> ; )
#=ITE                              ( #m #n -> :: <ob1> <ob3> <rest> ; )
                                   ( #m #n -> :: <ob2> <rest> ;       )
#=POSCOMP                          ( comp # -> #i )
                                   ( comp # -> #0 )
#>                                 ( # #' -> flag )
#>$                                ( # -> $ )
#>%                                ( hxs -> % )
#>1                                ( # -> flag )
#>2case                            ( #0/#1/#2 -> :: <ob2> <rest> ; )
                                   (        # -> :: <ob1> ;        )
#>?SKIP                            ( #m #n -> :: <ob1> <rest> ; )
                                   ( #m #n -> :: <ob2> <rest> ; )
#>case                             ( #m #n -> :: <ob2> <rest> ; )
                                   ( #m #n -> :: <ob1> ;        )
#>CHR                              ( # -> chr )
#>HXS                              ( # -> hxs )
#>ITE                              ( #m #n -> :: <ob2> <rest> ;       )
                                   ( #m #n -> :: <ob1> <ob3> <rest> ; )
#>ROMPTR                           ( #lib #cmd -> ROMPTR )
x#?                                ( x y -> 1 )
                                   ( x y -> 0 )
                                   UserRPL: x<>
#_102                              258d 102h
#AND                               ( # #' -> #'' )
(#CAlarmErr)                       3583d DFFh
#EXITERR                           458752d 70000h
#FIVE#FOUR                         (  -> #5 #4 )
#MAX                               ( # #' -> #'' )
#MIN                               ( # #' -> #'' )
(#NoRoomForSt)                     305d 131h
#ONE#27                            (  -> #1 #27d )
(#SyntaxErr)                       262d 106h
#THREE#FOUR                        (  -> #3 #4 )
#TWO#FOUR                          (  -> #2 #4 )
#TWO#ONE                           (  -> #2 #1 )
#TWO#TWO                           (  -> #2 #2 )
#ZERO#ONE                          (  -> #0 #1 )
#ZERO#SEVEN                        (  -> #0 #7 )
$1-+                               ( # #' -> #+#'-1 )
$5x7                               ( D.A B.A C.A D0 D1 --> )
                                   Displays string body at D1 in
                                   grob at D0 C.A = chars B.A =
                                   xlocation D.A = row length in
                                   nibbles -> D1 = addr after $
                                   D0 = location of next char
                                   D.A = row length
($<$?)                             ( $ $' -> flag )
($<=$?)                            ( $ $' -> flag )
($>$?)                             ( $ $' -> flag )
($>=$?)                            ( $ $' -> flag )
$>BIGGROB                          ( $ -> grob )
$>grob                             ( $ -> grob )
$>GROB                             ( $ -> grob )
(~$>grobOrGROB)                    ( $ -> grob )
$>ID                               ( $ -> ID )
$_''                               "''"
$_2DQ                              """"
($_:)                              ":"
$_::                               "::"
$_<<>>                             "®¯"
$_[]                               "[]"
$_ECHO                             "ECHO"
$_EXIT                             "EXIT"
$_GRAD                             "GRAD"
$_LRParens                         "()"
$_R<<                              "R"
$_R<Z                              "RZ"
$_RAD                              "RAD"
$_Undefined                        "Undefined"
$_XYZ                              "XYZ"
$_{}                               "{}"
($DER)                             "der"
x%                                 ( x y -> xy/100 )
%%*                                ( %% %%' -> %%*%%' )
%%*ROT                             ( ob ob' %% %%' -> ob' %%+%%' ob )
%%*SWAP                            ( ob %% %%' -> %%+%%' ob )
%%*UNROT                           ( ob ob' %% %%' -> %%+%%' ob ob' )
%%+                                ( %% %%' -> %%+%%' )
%%-                                ( %% %%' -> %%-%%' )
%%.1                               0.1
%%.4                               0.4
%%.5                               0.5
%%/                                ( %% %%' -> %%/%%' )
%%/>%                              ( %% %%' -> % )
%%0                                0
%%0<                               ( %% -> flag )
%%0<=                              ( %% -> flag )
%%0<>                              ( %% -> flag )
%%0=                               ( %% -> flag )
%%0>                               ( %% -> flag )
%%0>=                              ( %% -> flag )
%%1                                1
%%1/                               ( %% -> 1/%% )
%%10                               10
%%12                               12
%%2                                2
%%2PI                              2ã
%%3                                3
%%4                                4
%%5                                5
%%60                               60
%%7                                7
%%<                                ( %% %%' -> flag )
%%<=                               ( %% %%' -> falg )
%%>                                ( %% %%' -> flag )
%%>%                               ( %% -> % )
%%>=                               ( %% %%' -> flag )
%%>C%                              ( %%re %%im -> C% )
(%%>C%%)                           ( %%re %%im -> C%% )
%%^                                ( %% %%' -> %%^%%' )
%%ABS                              ( %% -> %%abs )
%%ACOSRAD                          ( %% -> %%rad )
%%ANGLE                            ( %%x %%y -> %%ang )
%%ANGLEDEG                         ( %%x %%y -> %%deg )
%%ANGLERAD                         ( %% -> %%' )
%%ASINRAD                          ( %% -> %%rad )
%%CHS                              ( %% -> -%% )
%%COS                              ( %% -> %%cos )
%%COSDEG                           ( %%deg -> %%cos )
%%COSH                             ( %% -> %%cosh )
%%COSRAD                           ( %%rad -> %%cos )
%%EXP                              ( %% -> e^%% )
%%FLOOR                            ( %% -> %%maxint )
%%H>HMS                            ( %% -> %%hms )
%%INT                              ( %% -> %%maxint )
(%%KZERO)                          273.15
%%LN                               ( %% -> ln %% )
%%LNP1                             ( %% -> %%ln(%%+1) )
%%MAX                              ( %% %%' -> %%max )
%%P>R                              ( %%r %%ang -> %%x %%y )
(%%PI)                             ã
%%R>P                              ( %%x %%y -> %%radius %%angle )
(%%RZERO)                          459.67
%%SIN                              ( %% -> %%sin )
%%SINDEG                           ( %%deg -> %%sin )
%%SINH                             ( %% -> %%sinh )
%%SINRAD                           ( %% -> %%' )
(%%SQR)                            ( %% -> %%' )
%%SQRT                             ( %% -> û%% )
(%%SUM)                            ( sym % % ob -> symf )
%%TANRAD                           ( %%rad -> %%tan )
%*                                 ( % %' -> %*%' )
%+                                 ( % %' -> %+%' )
%+SWAP                             ( ob % %' -> %+%' ob )
%-                                 ( % %' -> %-%' )
(%-.5)                             -.5
%-1                                -1
%-1=case                           ( %-1 -> :: %-1 <ob1> ;       )
                                   (  ob -> :: ob <ob2> <rest> ; )
%-2                                -2
%-3                                -3
%-4                                -4
%-5                                -5
%-6                                -6
%-7                                -7
%-8                                -8
%-9                                -9
%-MAXREAL                          -9.99E499
%-MINREAL                          -1E-499
%.1                                .1
(%.15)                             .15
%.5                                .5
%/                                 ( % %' -> %/%' )
%0                                 0
%0<                                ( % -> flag )
%0<>                               ( % -> flag )
%0<>                               ( % -> flag )
%0=                                ( % -> flag )
%0=case                            ( %0 -> :: %0 <ob1> ;        )
                                   ( ob -> :: ob <ob2> <rest> ; )
%0>                                ( % -> flag )
%0>=                               ( % -> flag )
%1                                 1
%1+                                ( % -> %+1 )
%1-                                ( % -> %-1 )
%1/                                ( % -> 1/% )
%10                                10
%10*                               ( % -> %*10 )
%100                               100
%11                                11
%12                                12
(%1200)                            1200
%13                                13
%14                                14
%15                                15
%16                                16
%17                                17
%18                                18
%180                               180
%19                                19
%1=case                            ( %1 -> :: %1 <ob1> ;        )
                                   ( ob -> :: ob <ob2> <rest> ; )
(%1pshm1)                          ( meta -> %1 #1 meta )
%2                                 2
%20                                20
(%200)                             200
%21                                21
%22                                22
%23                                23
%24                                24
(%2400)                            2400
%25                                25
%26                                26
%27                                27
%2=case                            ( %2 -> :: %2 <ob1> ;        )
                                   ( ob -> :: ob <ob2> <rest> ; )
(%2PI)                             2ã
%3                                 3
%360                               360
%4                                 4
(%400)                             400
(%4800)                            4800
%5                                 5
%6                                 6
%7                                 7
%8                                 8
%80                                80
%9                                 9
(%9600)                            9600
%<                                 ( % %' -> flag )
%<=                                ( % %' -> flag )
%<>                                ( % %' -> flag )
%=                                 ( % %' -> flag )
%>                                 ( % %' -> flag )
%>#                                ( % -> # )
%>%%                               ( % -> %% )
%>%%-                              ( % %' -> %%-%%' )
%>%%1/                             ( % -> 1/%% )
%>%%ANGLE                          ( %x %y -> %%ang )
%>%%SQRT                           ( % -> û%% )
%>%%SWAP                           ( ob % -> %% ob )
%>=                                ( % %' -> flag )
%>C%                               ( %re %im -> C% )
%>HMS                              ( % -> %hms )
%>TAG                              ( ob % -> tagged )
%^                                 ( % %' -> %^%' )
%ABS                               ( % -> %' )
%ABSCOERCE                         ( % -> # )
%ACOS                              ( % -> ACOS% )
%ACOSH                             ( % -> ACOSH% )
%ALOG                              ( % -> 10^% )
%ANGLE                             ( %x %y -> %ang )
(%ARG)                             ( % %' -> %rem )
%ASIN                              ( % -> ASIN% )
%ASINH                             ( % -> ASINH% )
%ATAN                              ( % -> ATAN% )
%ATANH                             ( % -> ATANH% )
%CEIL                              ( % -> %minint >=% )
x%CH                               ( x1 x2 -> x3 )
%CH                                ( % %' -> %pcchange )
%CHS                               ( % -> -% )
%COMB                              ( % %' -> COMB(%,%') )
%COS                               ( % -> COS% )
%COSH                              ( % -> COSH% )
%D>R                               ( %deg -> %rad )
%e                                 e
%EXP                               ( % -> e^% )
%EXPM1                             ( % -> e^%-1 )
%EXPONENT                          ( % -> %expn )
%FACT                              ( % -> gamma(%+1) )
%FLOOR                             ( % -> %maxint <=% )
%FP                                ( % -> %frac )
%HMS+                              ( %hms1 %hms2 -> %hms )
%HMS-                              ( %hms1 %hms2 -> %hms )
%HMS>                              ( %hms -> % )
(%IFTE)                            ( % ob1 ob2 -> ? )
(%INT)                             ( % %' -> %rem )
%IP                                ( % -> %int )
%IP>#                              ( % -> #IP(ABS(%)) )
%LN                                ( % -> LN% )
%LNP1                              ( % -> LN(%+1) )
%LOG                               ( % -> LOG% )
%MANTISSA                          ( % -> %mant )
%MAX                               ( % %' -> %greater )
(%MAXIMIZE)                        ( % %' -> %max %min )
%MAXorder                          ( % %' -> %max %min )
%MAXREAL                           9.99E499
%MIN                               ( % %' -> %lesser )
%MINREAL                           1E-499
%MOD                               ( % %' -> %rem )
%NFACT                             ( % -> %! )
%NROOT                             ( % %n -> %' )
%OF                                ( % %' -> %'/% * 100 )
%PERM                              ( % %' -> PERM(%,%') )
%PI                                ã
%POL>%REC                          ( %x %y -> %r %ang )
%R>D                               ( %rad -> %deg )
%RAN                               (  -> %random )
%RANDOMIZE                         ( %seed ->  )
%REC>%POL                          ( %r %ang -> %x %y )
%SGN                               ( % -> -1/0/1 )
%SIN                               ( % -> SIN% )
%SINH                              ( % -> SINH% )
%SPH>%REC                          ( %r %ang %ph -> %x %y %z )
(%SQ)                              ( % -> %' )
%SQRT                              ( % -> û% )
(%SYMSUM)                          ( sym % sym ob -> symf )
%T                                 ( % %' -> %pctotal )
x%T                                ( x y -> 100y/x )
%TAN                               ( % -> TAN% )
%TANH                              ( % -> TANH% )
(%TICKSday)                        707788800
(%TICKSmin)                        491520
(%TICKSsec)                        8192
(%TICKSweek)                       4954521600
&$                                 ( $ $' -> $+$' )
&$SWAP                             ( ob $ $' -> $+$' ob )
&COMP                              ( comp comp' -> comp'' )
&HXS                               ( hxs hxs' -> hxs'' )
'                                  (  -> nob (nextob) )
'DoBadKey                          (  -> DoBadKey )
'DoBadKeyT                         (  -> DoBadKey T )
'DROPFALSE                         (  -> DROPFALSE )
'ERRJMP                            (  -> ERRJMP )
('EvalNoCK:_sup)                   Run Stream:
                                   ( ob ->  )
('IDBAR)                           (  -> xBAR )
('IDCONIC)                         (  -> xCONIC )
'IDFUNCTION                        (  -> xFUNCTION )
('IDHISTOGRAM)                     (  -> xHISTOGRAM )
('IDPAR)                           (  -> id )
('IDPAR )                          (  -> id )
'IDPARAMETER                       (  -> xPARAMETRIC )
'IDPOLAR                           (  -> xPOLAR )
('IDSCATTER)                       (  -> xSCATTER )
('IDTRUTH)                         (  -> xTRUTH )
('idUserKeys)                      (  -> id )
('idUserKeys.)                     (  -> id )
'IDX                               (  -> id )
'LAMLNAMESTO                       ( ob ->  )
'NOP                               (  -> NOP )
'R                                 (  -> ob )
'R'R                               (  -> ob1 ob2 )
'Rapndit                           ( meta ob1...ob4 -> meta&ob ob1...ob4 )
'REVAL                             (  -> ? )
'RRDROP                            (  -> ob )
'RSaveRomWrd                       (  ->  )
'RSAVEWORD                         (  ->  )
'x*                                (  -> x* )
'xDER                              (  -> xDER )
'xDEREQ                            ( ob -> flag )
x*                                 ( x y -> x*y )
x*H                                ( xf ->  )
                                   UserRPL: xSCALEH
x*W                                ( yf ->  )
                                   UserRPL: xSCALEW
x+                                 ( x y -> x+y )
+LOOP                              ( # ->  )
x-                                 ( x y -> x-y )
x->Q                               ( x -> a/b )
                                   UserRPL: x->Q
x->QPI                             ( x -> symb )
                                   UserRPL: x->Qã
x->TAG                             ( ob tag -> :tag:ob )
                                   UserRPL: x->TAG
x/                                 ( x y -> x/y )
0LASTOWDOB!                        (  ->  )
0LASTOWDOB!                        (  ->  )
0LastRomWrd!                       (  ->  )
10GETLAM                           (  -> ob )
10PUTLAM                           ( ob ->  )
10UNROLL                           ( 1..10 -> 10 1..9 )
11GETLAM                           (  -> ob )
11PUTLAM                           ( ob ->  )
12GETLAM                           (  -> ob )
12PUTLAM                           ( ob ->  )
13GETLAM                           (  -> ob )
13PUTLAM                           ( ob ->  )
14GETLAM                           (  -> ob )
14PUTLAM                           ( ob ->  )
(14SPACES$)                        "              "
15GETLAM                           (  -> ob )
15PUTLAM                           ( ob ->  )
16GETLAM                           (  -> ob )
16PUTLAM                           ( ob ->  )
17GETLAM                           (  -> ob )
17PUTLAM                           ( ob ->  )
18GETLAM                           (  -> ob )
18PUTLAM                           ( ob ->  )
19GETLAM                           (  -> ob )
19PUTLAM                           ( ob ->  )
1_#1-SUB                           ( $ #end -> $' )
1_#1-SUB$                          ( $ #end -> $' )
1A/LockA                           (  ->  )
1ABNDSWAP                          ( ob -> 1lamob ob )
1GETABND                           (  -> 1lamob )
1GETLAM                            (  -> ob )
1GETLAMSWP1+                       ( # -> 1lamob #+1 )
1GETSWAP                           ( ob -> 1lamob ob )
1LAMBIND                           ( ob ->  )
1NULLLAM{}                         (  -> {} )
(1POLKeyUI)                        (  ->  )
1PUTLAM                            ( ob ->  )
1REV                               (  -> 6.28318530718 )
                                   (  -> 360.          )
                                   (  -> 400.          )
1stkdecomp$w                       ( ob -> $ )
2#0=OR                             ( # # -> flag )
2%%>%                              ( %% %%' -> % %' )
2%>%%                              ( % % -> %% %% )
(2%>%%SQR)                         ( %r %ang %ph -> %x %y %z )
2'RCOLARPITE                       Return to composite and ITE there.
20GETLAM                           (  -> ob )
20PUTLAM                           ( ob ->  )
21GETLAM                           (  -> ob )
21PUTLAM                           ( ob ->  )
22GETLAM                           (  -> ob )
22PUTLAM                           ( ob ->  )
2@REVAL                            (  ->  )
2DROP                              ( 1 2 ->  )
(2DROP%0 )                         ( ob ob' -> %0 )
2DROP00                            ( ob ob -> #0 #0 )
(2DROP2dropf)                      ( meta1 meta2 ob1 ob2 -> F )
2DropBadKey                        ( ob ob' ->  )
2DROPFALSE                         ( ob1 ob2 -> F )
(2DROPTRUE)                        ( ob ob' -> T )
2DUP                               ( 1 2 -> 1 2 1 2 )
2DUP#+                             ( # #' -> # #' #+#' )
2DUP#<                             ( # #' -> # #' flag )
2DUP#=                             ( # #' -> # #' flag )
2DUP#>                             ( # #' -> # #' flag )
2DUP5ROLL                          ( 1 2 3 -> 2 3 2 3 1 )
2DUPEQ                             ( ob1 ob2 -> ob1 ob2 flag )
2DUPSWAP                           ( 1 2 -> 1 2 2 1 )
2DUPSWAP                           ( 1 2 -> 1 2 2 1 )
2EXT                               238d EEh
2GETEVAL                           (  -> ? )
2GETLAM                            (  -> ob )
2GROB                              204d CCh
(2HXS)                             187d BBh
(2HXS>#)                           ( hxs hxs -> # # )
2HXSLIST?                          ( { hxs hxs' } -> # #' )
(2LEN$#+)                          ( $ $' -> $ $' # )
2LIST                              85d 55h
(2NULLLAM{})                       (  -> {} )
2Ob>Seco                           ( ob1 ob2 -> :: ob1 ob2 ; )
2OVER                              ( 1 2 3 4 -> 1 2 3 4 1 2 )
(2psh1&rev:)                       ( meta1 meta2 -> meta1&ob meta2&ob )
(2pull2DROP)                       ( meta&ob1&ob2 -> meta )
2PUTLAM                            ( ob ->  )
2RDROP                             (  ->  )
2REAL                              17d 11h
(2Repl-1)                          ( meta1 meta2 -> %-1 #1 )
(2Repl0)                           ( meta1 meta2 -> %0 #1 )
(2SINNER)                          ( ob1 ob2 -> meta1 meta2 )
(2SINNERtop&)                      ( ob1 ob2 -> meta )
(2SKIP)                            Skips 2 objs in the runstream.
2skipcola                          Does 2SKIP, then COLA.
2SWAP                              ( 1 2 3 4 -> 3 4 1 2 )
(2top&)                            ( meta1 meta2 meta3 -> meta1&meta2&meta3 )
3@REVAL                            (  ->  )
(3ARRY)                            1092d 444h
3DROP                              ( 1 2 3 ->  )
(3DROPTRUE)                        ( ob1 ob2 ob3 -> T )
(3DROPZERO)                        ( ob ob ob -> #0 )
3GETLAM                            (  -> ob )
(3NULLLAM{})                       (  -> {} )
3PICK                              ( 1 2 3 -> 1 2 3 1 )
3PICK#+                            ( # ob #' -> # ob #'+# )
3PICK3PICK                         ( 1 2 3 -> 1 2 3 1 2 )
3PICKOVER                          ( 1 2 3 -> 1 2 3 1 3 )
3PICKSWAP                          ( 1 2 3 -> 1 2 1 3 )
3PUTLAM                            ( ob ->  )
3RDROP                             (  ->  )
3REAL                              273d 111h
(3SKIP)                            Skips 3 objs in the runstream.
3skipcola                          Does 3SKIP, then COLA.
(3SYM)                             2730d AAAh
3UNROLL                            ( 1 2 3 -> 3 1 2 )
3UNROLL                            ( 1 2 3 -> 3 1 2 )
4DROP                              ( 1..4 ->  )
(4DROP%0)                          ( 1...4 -> %0 )
(4DROPFALSE)                       ( ob1..ob4 -> F )
4DropLoop                          Pop 4, Loop
(4DROPTRUE)                        ( ob1..ob4 -> T )
4GETLAM                            (  -> ob )
(4NULLLAM{})                       (  -> {} )
4PICK                              ( 1 2 3 4 -> 1 2 3 4 1 )
4PICK#+                            ( # ob1 ob2 #' -> # ob1 ob2 #'+# )
4PICK#+SWAP                        ( # ob1 ob2 #' -> # ob1 #'+# ob2 )
4PICK+SWAP                         ( # ob1 ob2 #' -> # ob1 #'+# ob2 )
4PICKOVER                          ( 1 2 3 4 -> 1 2 3 4 1 4 )
4PICKSWAP                          ( 1 2 3 4 -> 1 2 3 1 4 )
(4psh)                             ( meta1 ob1..ob4 -> ob1&..ob4 meta1 )
4PUTLAM                            ( ob ->  )
(4roll)                            ( meta1 meta2 meta3 meta4 -> meta2 meta3 meta4 meta1 )
4ROLL                              ( 1 2 3 4 -> 2 3 4 1 )
4ROLLDROP                          ( 1 2 3 4 -> 2 3 4 )
4ROLLOVER                          ( 1 2 3 4 -> 2 3 4 1 4 )
4ROLLROT                           ( 1 2 3 4 -> 2 4 1 3 )
4ROLLSWAP                          ( 1 2 3 4 -> 2 3 1 4 )
(4rollunrot)                       ( meta1 meta2 meta3 meta4 -> meta2 meta1 meta3 meta4 )
4UNROLL                            ( 1 2 3 4 -> 4 1 2 3 )
(4unroll)                          ( meta1 meta2 meta3 meta4 -> meta4 meta1 meta2 meta3 )
4UNROLL3DROP                       ( 1 2 3 4 -> 4 )
4UNROLLDUP                         ( 1 2 3 4 -> 4 1 2 3 3 )
4UNROLLROT                         ( 1 2 3 4 -> 4 3 2 1 )
5DROP                              ( 1..5 ->  )
(5DROPFALSE)                       ( ob1..ob5 -> F )
5GETLAM                            (  -> ob )
5PICK                              ( 1 2 3 4 5 -> 1 2 3 4 5 1 )
5PUTLAM                            ( ob ->  )
5ROLL                              ( 1 2 3 4 5 -> 2 3 4 5 1 )
(5roll)                            ( meta1..meta5 -> meta2..meta5 meta1 )
5ROLLDROP                          ( 1 2 3 4 5 -> 2 3 4 5 )
5skipcola                          Skips 5 objects, then does COLA.
5UNROLL                            ( 1 2 3 4 5 -> 5 1 2 3 4 )
(5unroll)                          ( meta1..meta5 -> meta5 meta1..meta4 )
6DROP                              ( 1..6 ->  )
6GETLAM                            (  -> ob )
6PICK                              ( 1..6 -> 1..6 1 )
6PUTLAM                            ( ob ->  )
6ROLL                              ( 1..6 -> 2..6 1 )
6UNROLL                            ( 1..6 -> 6 1..5 )
7DROP                              ( 1..7 ->  )
7GETLAM                            (  -> ob )
(7NULLLAM{})                       (  -> {} )
7PICK                              ( 1..7 -> 1..7 1 )
7PUTLAM                            ( ob ->  )
7ROLL                              ( 1..7 -> 2..7 1 )
7UNROLL                            ( 1..7 -> 7 1..6 )
8GETLAM                            (  -> ob )
(8NULLLAM{})                       (  -> {} )
8PICK                              ( 1..8 -> 1..8 1 )
8PUTLAM                            ( ob ->  )
8ROLL                              ( 1..8 -> 2..8 1 )
8UNROLL                            ( 1..8 -> 8 1..7 )
9GETLAM                            (  -> ob )
9PUTLAM                            ( ob ->  )
::N                                ( ob1..obn #n -> :: ob1..obn ; )
::NEVAL                            ( ob1..obn #n -> ? )
x<                                 ( x y -> 1 )
                                   ( x y -> 0 )
x<=?                               ( x y -> 1 )
                                   ( x y -> 0 )
                                   UserRPL: xó
<DelKey                            (  -> {} )
<SkipKey                           (  -> {} )
x=                                 ( x y -> x=y )
x==                                ( x y -> 1 )
                                   ( x y -> 0 )
x>                                 ( x y -> 1 )
                                   ( x y -> 0 )
x>=?                               ( x y -> 1 )
                                   ( x y -> 0 )
                                   UserRPL: xò
(>ALRMLS)                          ( $ %date %time %rpt -> {} )
x>ARRY                             (        x1..xn n -> []   )
                                   ( x11...xnm {n m} -> [[]] )
                                   UserRPL: x->ARRY
(>ARRY)                            ( F%..F% #n [%F] -> [F%]' )
>BAK                               ( id ob -> bak )
(>DATE)                            ( %date ->  )
>DelKey                            (  -> {} )
(>dvars)                           ( meta1 meta2 -> meta1&meta2' )
x>GROB                             ( ob n_chrsize -> grob )
                                   UserRPL: x->GROB
>H$                                ( $ chr -> $' )
>HCOMP                             ( comp ob -> ob+comp )
x>HMS                              ( x -> x' )
                                   UserRPL: x->HMS
x>LCD                              ( grob ->  )
                                   UserRPL: x->LCD
x>LIST                             ( ob1 .. obn n -> {} )
                                   UserRPL: x->LIST
(>MENU)                            ( #col grob ->  )
                                   (    #col $ ->  )
                                   (   #col id ->  )
                                   (   #col :: ->  )
x>NUM                              ( x -> x' )
                                   UserRPL: x->NUM
>R                                 ( :: ->  )
>Review$                           ( id -> $ )
>SkipKey                           (  -> {} )
x>STR                              ( ob -> $ )
                                   UserRPL: x->STR
>T$                                ( $ chr -> $' )
>TAG                               ( ob $tag -> tagged )
>TCOMP                             ( comp ob -> comp+ob )
(>TIME)                            ( %time ->  )
(>TOPTEMP)                         ( ob -> ob' )
x>UNIT                             ( x u -> u' )
                                   UserRPL: x->UNIT
x>V2                               ( x y -> [] )
                                   ( x y -> () )
                                   UserRPL: x->V2
x>V3                               ( x y z -> [] )
                                   UserRPL: x->V3
?>ROMPTR                           ( ob -> ob' )
(?addinver:)                       ( meta&Nob -> meta      )
                                   (     meta -> meta&1LAM )
(?addrever)                        ( meta&1LAM -> meta&1LAM )
                                   (      meta -> meta&1LAM )
(?addsimir)                        ( meta meta -> meta )
?ATTN_QUIT                         (  ->  )
?ATTNQUIT                          (  ->  )
?BlinkCursor                       (  ->  )
?CARCOMP                           ( comp T -> ob   )
                                   ( comp F -> comp )
?CaseKeyDef                        ( # #' -> :: ' ob1 T ;      )
                                   ( # #' -> :: <ob2> <rest> ; )
?CaseRomptr@                       ( # #' -> ob T              )
                                   ( # #' -> F                 )
                                   ( # #' -> :: <ob2> <rest> ; )
?ClrAlg                            (  ->  )
?ClrAlgSetPr                       (  ->  )
?DispMenu                          (  ->  )
?DispMenu                          (  ->  )
?DispStack                         (  ->  )
?DispStatus                        (  ->  )
?FlashAlert                        (  ->  )
?GOTO                              ( flag ->  )
?Ob>Seco                           ( ob -> :: ob ; )
?OKINALG                           ( ob -> ob flag )
?PURGE_HERE                        ( id ->  )
?ROMPTR>                           ( ob -> ob' )
?SEMI                              ( T -> :: ;              )
                                   ( F -> :: <ob1> <rest> ; )
?SEMIDROP                          ( ob T -> :: ob ;           )
                                   ( ob F -> :: <ob1> <rest> ; )
(?SetEditRoll)                     :: EditExst?NOT ITE SetDA2RollF SetDA2aNoCh ;
?SKIP                              ( T -> :: <ob2> <rest> ; )
                                   ( F -> :: <ob1> <rest> ; )
?SKIPSWAP                          ( ob1 ob2 T -> :: ob1 ob2 <ob1> <rest> ; )
                                   ( ob1 ob2 F -> :: ob2 ob1 <ob1> <rest> ; )
(?spliteq)                         ( meta1&meta2&= -> meta2 meta1 )
?STO_HERE                          ( ob id/lam ->  )
?SWAP                              ( ob1 ob2 T -> :: ob2 ob1 <ob1> <rest> ; )
                                   ( ob1 ob2 F -> :: ob1 ob2 <ob1> <rest> ; )
?SWAPDROP                          ( ob1 ob2 T -> :: ob1 <ob1> <rest> ; )
                                   ( ob1 ob2 F -> :: ob2 <ob1> <rest> ; )
?TogU/LCase                        ( chr -> chr' )
@                                  ( id/lam -> ob T )
                                   ( id/lam -> F    )
@LAM                               ( lam -> ob T )
                                   ( lam -> F    )
(@LAMNOT)                          ( lam -> ob F  )
                                   ( lam -> lam T )
(@OBNOT)                           ( ob -> ob' F )
                                   ( ob -> ob T  )
x^                                 ( y x -> y^x )
a%>$                               ( % -> $ )
a%>$,                              ( % -> $ )
ABND                               (  ->  )
ABORT                              (  ->  )
xABS                               ( x -> x' )
ABUFF                              (  -> textgrob )
xACK                               (  ->  )
xACKALL                            (  ->  )
(ACKALLALMS)                       (  ->  )
(ACKALM)                           (  -> flag )
xACOS                              ( x -> x' )
xACOSH                             ( x -> x' )
(addt*)                            ( meta -> meta&* )
(addt+)                            ( meta -> meta&+ )
(addt-)                            ( meta -> meta&- )
(addt2:)                           ( meta -> meta&ob1&ob2 )
(addt:)                            ( meta -> meta&ob )
(addtINV)                          ( meta -> meta&INV )
(addtNEG)                          ( meta -> meta&NEG )
(addtpsh)                          ( meta1 meta2 ob -> meta1&ob meta2 )
ADJMEM                             D= @FREETOP=<see>ROOM / 5
                                   Uses A.10 B.10 C.10 D.10 <see>DIV5
AEQ1stcase                         ( meta&ob -> ob=nob ? case )
AEQopscase                         meta1&ob1 meta2&ob2
AGAIN                              (  ->  )
AINRTN                             A=IN see also <see>CINRTN
                                   For hardware reasons (bug)
                                   A=IN must be at even addr
ALARM?                             (  -> flag )
ALARMS@                            (  -> {} )
(Alert$)                           ( # -> $ )
(AlertStatus)                      (  -> # )
AlgEntry?                          (  -> flag )
AllowIntr                          Allow interrupts.
xALOG                              ( x -> x' )
(ALRMLS>)                          ( {} -> {}' )
xAND                               ( x1 x2 -> x3 )
AND                                ( flag1 flag2 -> flag )
AND$                               ( $1 $2 -> $' )
ANDcase                            ( f1 f2 -> :: <ob1> ;        )
                                   ( f1 f2 -> :: <ob2> <rest> ; )
ANDITE                             ( f1 f2 -> :: <ob1> <ob3> <rest> ; )
                                   ( f1 f2 -> :: <ob2> <rest> ;       )
ANDNOTcase                         ( f1 f2 -> :: <ob1> ;        )
                                   ( f1 f2 -> :: <ob2> <rest> ; )
ANNCTRL                            Annunciator control
                                   [LA4 LA3 LA2 LA1]
                                   (alarm alpha -> <-)
(ANNCTRL2)                         Annunciator control
                                   [AON XTRA LA6 LA5]
                                   (on extra io busy)
any                                0d 0h
APNDCRLF                           ( $ -> $' )
APNDCRLF                           ( $ -> $' )
apndvarlst                         ( {} ob -> {}' )
AppDisplay!                        ( ob ->  )
AppDisplay@                        (  ->  )
APPEND_SPACE                       ( $ -> $' )
AppError!                          ( ob ->  )
(AppError?)                        (  -> flag )
AppError@                          (  -> ob )
AppExitCond!                       ( ob ->  )
AppExitCond@                       (  -> ob )
AppKeys!                           ( ob ->  )
AppKeys0                           ???
xAPPLY                             ( {symb1 .. symbn} f -> f(symb1...symbn) )
AppMode?                           (  -> flag )
(AppSuspOK?)                       (  ->  )
xARC                               (        c r é1 é2 ->  )
                                   ( {#x #y} #r é1 é2 ->  )
xARCHIVE                           ( :port:name ->  )
                                   (   :IO:name ->  )
xARG                               ( c -> é )
(ARGNUMERR)                        Error 128h
argtypeerr                         "Bad Argument Type"
(argum)                            ( seco -> seco #args )
argvalerr                          "Bad Argument Value"
arry                               4d 4h
xARRY>                             (   [] -> x1...xn {n}     )
                                   ( [[]] -> x11...xnm {n m} )
                                   UserRPL: xARRY->
(ARRYEL?)                          ( {#n #m} [] -> # T )
                                   ( {#n #m} [] -> F   )
(ARRYLISTCMP)                      1106d 452h
(ARRYLISTREAL)                     1105d 451h
ARRYREAL                           65d 41h
(ARRYREALCMP)                      1042d 412h
(ARRYREALREAL)                     1041d 411h
ARSIZE                             ( [] -> # )
xASIN                              ( x -> x' )
xASINH                             ( x -> x' )
ASLW5                              ASL.W 5 times
xASN                               ( obj key ->  )
                                   (  'SKEY' ->  )
xASR                               ( # -> #' )
ASRW5                              ASR.W 5 times
xATAN                              ( x -> x' )
xATANH                             ( x -> x' )
xATTACH                            ( n ->  )
ATTN#                              2563d A03h
Attn#                              2563d A03h
(Attn?)                            Sets carry when ATTNFLG <> 0.
ATTN?                              (  -> flag )
ATTNchk                            ATTN exit check with restoreiram
ATTNERR                            2563d A03h
ATTNFLG@                           (  -> # )
ATTNFLGCLR                         (  ->  )
AtUserStack                        (  ->  )
xAUTO                              (  ->  )
AUTOSCALE                          (  ->  )
xAXES                              (               c ->  )
                                   ( {c tick $x $y } ->  )
(B%0=)                             ( B% -> flag )
(B%ABS)                            ( B% -> B%' )
(B%NEG)                            ( B% -> B%' )
xB>R                               ( # -> R )
                                   UserRPL: xB->R
BAK>OB                             ( bak -> ob )
BAKNAME                            ( bak -> id T )
(BANGARRY)                         ( el # M -> M' )
xBAR                               (  ->  )
xBARPLOT                           (  ->  )
BASE                               (  -> # )
(BASECHAR)                         (  -> char )
xBAUD                              ( n ->  )
(~BBDownArrow)                     (  -> grob )
(~BBEmpty?)                        (  -> flag )
(~BBGetDefltHeight)                (  -> # )
(~BBGetN)                          ( #n -> ob )
(~BBGetNGrob)                      ( #n -> grob )
(~BBGetNStr)                       ( #n -> $ )
(~BBIsChecked?)                    ( #n -> flag )
(~BBMoveTo)                        ( # ->  )
(BBox/StdLbl:)                     (  -> grob )
(~BBPgDown)                        (  ->  )
(~BBPgUp)                          (  ->  )
(~BBRecalOff&Disp)                 ( flag ->  )
(~BBReDrawBackgr)                  (  ->  )
(~BBRereadChkEnbl)                 (  ->  )
(~BBReReadCoords)                  (  ->  )
(~BBRereadFullScr)                 (  ->  )
(~BBReReadHeight)                  (  ->  )
(~BBReReadNElems)                  (  ->  )
(~BBReReadPageSize)                (  ->  )
(~BBReReadWidth)                   (  ->  )
(~BBRunCanclAction)                (  ->  )
(~BBRunENTERAction)                (  ->  )
(~BBRunEntryProc)                  (  ->  )
(~BBSpace)                         (  -> grob )
(~BBUpArrow)                       (  -> grob )
xBEEP                              ( freq dur ->  )
BEGIN                              (  ->  )
xBESTFIT                           (  ->  )
BigCursor                          (  -> grob )
BIGDISPN                           ( $ #row ->  )
BIGDISPROW1                        ( $ ->  )
BIGDISPROW2                        ( $ ->  )
BIGDISPROW3                        ( $ ->  )
BIGDISPROW4                        ( $ ->  )
xBIN                               (  ->  )
BIND                               ( obn..ob1 {lamn..lam1} ->  )
xBINS                              ( min width n -> [[]] [] )
BINT0                              0d 0h
BINT1                              1d 1h
BINT10                             10d  Ah
BINT100                            100d 64h
(BINT101)                          101d 65h
BINT11                             11d  Bh
BINT111                            111d 6Fh
(BINT112)                          112d 70h
(BINT113)                          113d 71h
(BINT114)                          114d 72h
BINT115                            115d 73h
BINT116                            116d 74h
(BINT117)                          117d 75h
BINT12                             12d  Ch
BINT122                            122d 7Ah
BINT128                            128d 80h
BINT13                             13d  Dh
BINT130                            130d 82h
BINT130d                           130d 82h
BINT131                            131d 83h
BINT131d                           131d 83h
BINT14                             14d  Eh
BINT15                             15d  Fh
BINT16                             16d 10h
BINT17                             17d 11h
BINT18                             18d 12h
BINT19                             19d 13h
BINT2                              2d 2h
BINT20                             20d 14h
BINT21                             21d 15h
BINT22                             22d 16h
BINT23                             23d 17h
BINT24                             24d 18h
BINT25                             25d 19h
BINT253                            253d FDh
BINT255d                           255d FFh
BINT26                             26d 1Ah
BINT27                             27d 1Bh
BINT28                             28d 1Ch
BINT29                             29d 1Dh
BINT3                              3d 3h
BINT30                             30d 1Eh
BINT31                             31d 1Fh
BINT32                             32d 20h
BINT33                             33d 21h
BINT34                             34d 22h
BINT35                             35d 23h
BINT36                             36d 24h
BINT37                             37d 25h
BINT38                             38d 26h
BINT39                             39d 27h
BINT4                              4d 4h
BINT40                             40d 28h
BINT40h                            64d 40h
BINT41                             41d 29h
BINT42                             42d 2Ah
BINT43                             43d 2Bh
BINT44                             44d 2Ch
BINT45                             45d 2Dh
BINT46                             46d 2Eh
BINT47                             47d 2Fh
BINT48                             48d 30h
BINT49                             49d 31h
BINT5                              5d 5h
BINT50                             50d 32h
BINT51                             51d 33h
BINT52                             52d 34h
BINT53                             53d 35h
BINT54                             54d 36h
BINT55                             55d 37h
BINT56                             56d 38h
BINT57                             57d 39h
BINT58                             58d 3Ah
BINT59                             59d 3Bh
BINT6                              6d 6h
BINT60                             60d 3Ch
BINT61                             61d 3Dh
BINT62                             62d 3Eh
BINT63                             63d 3Fh
BINT64                             64d 40h
BINT65                             65d 41h
BINT66                             66d 42h
BINT67                             67d 43h
BINT68                             68d 44h
BINT69                             69d 45h
BINT7                              7d 7h
BINT70                             70d 46h
BINT74                             74d 4Ah
BINT79                             79d 4Fh
BINT8                              8d 8h
BINT80                             80d 50h
BINT80h                            128d 80h
BINT81                             81d 51h
BINT82                             82d 52h
BINT83                             83d 53h
BINT84                             84d 54h
BINT85                             85d 55h
BINT86                             86d 56h
BINT87                             87d 57h
BINT9                              9d 9h
BINT91                             91d 5Bh
BINT96                             96d 60h
BINT97                             97d 61h
(BINT98)                           98d 62h
BINT_115d                          115d 73h
BINT_116d                          116d 74h
(BINT_117h)                        279d 117h
BINT_122d                          122d 7Ah
BINT_130d                          130d 82h
BINT_131d                          131d 83h
(BINT_263d)                        263d 107h
BINT_91d                           91d 5Bh
BINT_96d                           96d 60h
(BINT_AFh)                         175d AFh
BINTC0h                            192d C0h
bit#%*                             ( hxs % -> hxs' )
bit#%+                             ( hxs % -> hxs' )
bit#%-                             ( hxs % -> hxs' )
bit#%/                             ( hxs % -> hxs' )
bit%#*                             ( % hxs -> hxs' )
bit%#+                             ( % hxs -> hxs' )
bit%#-                             ( % hxs -> hxs' )
bit%#/                             ( % hxs -> hxs' )
bit*                               ( hxs hxs' -> hxs'' )
bit+                               ( hxs hxs' -> hxs'' )
bit-                               ( hxs hxs' -> hxs'' )
bit/                               ( hxs hxs' -> hxs'' )
bitAND                             ( hxs hxs' -> hxs'' )
bitASR                             ( hxs -> hxs' )
(bitNEG)                           ( hxs -> hxs' )
bitNOT                             ( hxs -> hxs' )
bitOR                              ( hxs hxs' -> hxs'' )
bitRL                              ( hxs -> hxs' )
bitRLB                             ( hxs -> hxs' )
bitRR                              ( hxs -> hxs' )
bitRRB                             ( hxs -> hxs' )
bitSL                              ( hxs -> hxs' )
bitSLB                             ( hxs -> hxs' )
bitSR                              ( hxs -> hxs' )
bitSRB                             ( hxs -> hxs' )
bitXOR                             ( hxs hxs' -> hxs'' )
xBLANK                             ( #width #height -> grob )
Blank$                             ( #len -> $ )
Blank&GROB!                        ( $ #x #x1 #x2 ->  )
BlankDA1                           (  ->  )
BlankDA12                          (  ->  )
BlankDA2                           (  ->  )
BlankDA2a                          (  ->  )
BLANKIT                            ( #startrow #rows ->  )
(BodyMore?)                        ( ob1 ob2 -> flag )
BOTROW                             (  -> #y )
xBOX                               ( {#n1 #m1} {#n2 #m2} ->  )
                                   (               c1 c2 ->  )
Box/StdLabel                       ( $ flag -> grob )
Box/StdLbl:                        (  -> grob )
(BoxLabelGrob)                     21x8 menu key with box
(~BReReadMenus)                    (  ->  )
(BROADENGROB)                      ( grob #cols ->  )
(BROADENHBUFF)                     ( #cols ->  )
~BRRclC1                           (  ->  )
xBUFLEN                            (  -> nchars 0/1 )
xBYTES                             ( obj -> chksum size )
C%%0=                              ( C%% -> flag )
C%%1                               (Q%%1,%%0Q)
C%%>%%                             ( C%% -> %%re %%im )
C%%>C%                             ( C%% -> C% )
(C%%ABS)                           ( C%% -> %% )
(C%%C*C)                           ( C%% C%%' -> C%%'' )
(C%%C*R)                           ( C%% %% -> C%%' )
(C%%C+C)                           ( C%% C%%' -> C%%'' )
(C%%C+R)                           ( C%% %% -> C%%' )
(C%%C-C)                           ( C%% C%%' -> C%%'' )
(C%%C-R)                           ( C%% %% -> C%%' )
(C%%C/C)                           ( C%% C%%' -> C%%'' )
(C%%C/R)                           ( C%% %% -> C%%' )
C%%CHS                             ( C%% -> -C%% )
C%%CONJ                            ( C%% -> C%%' )
(C%%R*C)                           ( %% C%% -> C%%' )
(C%%R+C)                           ( %% C%% -> C%%' )
(C%%R-C)                           ( %% C%% -> C%%' )
(C%%R/C)                           ( %% C%% -> C%%' )
(C%*i)                             ( C% -> C%' )
C%-1                               (-1,0)
C%-1=case                          ( C%-1 -> :: C%-1 <ob1> ;   )
                                   (   ob -> ob <ob2> <rest> ; )
(C%-i)                             (0,-1)
C%0                                (0,0)
C%0=                               ( C% -> flag )
C%0=case                           ( C%0 -> :: C%0 <ob1> ;       )
                                   (  ob -> :: ob <ob2> <rest> ; )
C%1                                (1,0)
C%1/                               ( C% -> 1/C% )
C%1=case                           ( C%1 -> :: C%1 <ob1> ;       )
                                   (  ob -> :: ob <ob2> <rest> ; )
C%2=case                           ( C%2 -> :: C%2 <ob1> ;       )
                                   (  ob -> :: ob <ob2> <rest> ; )
C%>#                               ( C% -> # #' )
C%>%                               ( C% -> %re %im )
C%>%%                              ( C% -> %%re %%im )
C%>%%SWAP                          ( C% -> %%im %%re )
C%ABS                              ( C% -> % )
C%ACOS                             ( C% -> acos C% )
C%ACOSH                            ( C% -> acosh C% )
C%ALOG                             ( C% -> 10^C% )
C%ARG                              ( C% -> % )
C%ASIN                             ( C% -> asin C% )
C%ASINH                            ( C% -> asinh C% )
C%ATAN                             ( C% -> atan C% )
C%ATANH                            ( C% -> atanh C% )
(C%C*C)                            ( C% C%' -> C%'' )
(C%C*C )                           ( C% -> C%^2 )
(C%C*R)                            ( C% % -> C%' )
(C%C+C)                            ( C% C%' -> C%'' )
(C%C+R)                            ( C% % -> C%' )
(C%C-C)                            ( C% C%' -> C%'' )
(C%C-R)                            ( C% % -> C%' )
(C%C/C)                            ( C% C%' -> C%'' )
(C%C/R)                            ( C% % -> C%' )
C%C^C                              ( C% C%' -> C%'' )
C%C^R                              ( C% % -> C%' )
C%CHS                              ( C% -> -C% )
C%CONJ                             ( C% -> C%' )
C%COS                              ( C% -> cos C% )
C%COSH                             ( C% -> cosh C% )
C%EXP                              ( C% -> e^C% )
(C%i)                              (0,1)
C%LN                               ( C% -> ln C% )
C%LOG                              ( C% -> log C% )
(C%R*C)                            ( % C% -> C%' )
(C%R+C)                            ( % C% -> C%' )
(C%R-C)                            ( % C% -> C%' )
(C%R/C)                            ( % C% -> C%' )
C%R^C                              ( % C% -> C%' )
C%SGN                              ( C% -> C%/C%ABS )
C%SIN                              ( C% -> sin C% )
C%SINH                             ( C% -> sinh C% )
C%SQRT                             ( C% -> ûC% )
C%TAN                              ( C% -> tan C% )
C%TANH                             ( C% -> tanh C% )
(C/i)                              ( C% -> C%' )
C>Im%                              ( C% -> %im )
xC>PX                              ( (x,y) -> {#n #m} )
                                   UserRPL: xC->PX
xC>R                               ( (x,y) -> x y )
                                   UserRPL: xC->R
C>Re%                              ( C% -> %re )
CACHE                              ( obn..ob1 #n lam ->  )
CacheStack                         (  ->  )
(CALCINTEG)                        ( seco %precision %lo %hi -> %integral %error )
CAR$                               ( $ -> chr )
CARCOMP                            (      comp -> ob_head   )
                                   ( comp_null -> comp_null )
xCASE                              (  ->  )
case                               ( T -> :: <ob1> ;        )
                                   ( F -> :: <ob2> <rest> ; )
case2DROP                          ( ob1 ob2 T -> :: ;                      )
                                   ( ob1 ob2 F -> :: ob1 ob2 <ob1> <rest> ; )
case2drop                          ( ob1 ob2 T -> :: <ob1> ;                )
                                   ( ob1 ob2 F -> :: ob1 ob2 <ob2> <rest> ; )
case2drpfls                        ( ob1 ob2 T -> F                         )
                                   ( ob1 ob2 F -> :: ob1 ob2 <ob1> <rest> ; )
caseDEADKEY                        ( T -> :: DoBadKey ;     )
                                   ( F -> :: <ob1> <rest> ; )
caseDoBadKey                       ( T -> :: DoBadKey ;     )
                                   ( F -> :: <ob1> <rest> ; )
casedrop                           ( ob T -> :: <ob1> ;           )
                                   ( ob F -> :: ob <ob2> <rest> ; )
caseDROP                           ( ob T -> :: ;                 )
                                   ( ob F -> :: ob <ob1> <rest> ; )
caseDrpBadKy                       ( ob T -> :: DoBadKey ;        )
                                   ( ob F -> :: ob <ob1> <rest> ; )
casedrpfls                         ( ob T -> F                    )
                                   ( ob F -> :: ob <ob1> <rest> ; )
casedrptru                         ( ob T -> T                    )
                                   ( ob F -> :: ob <ob1> <rest> ; )
caseERRJMP                         ( T -> :: ERRJMP ;      )
                                   ( F -> :: <ob> <rest> ; )
caseFALSE                          ( T -> F                 )
                                   ( F -> :: <ob1> <rest> ; )
caseSIZEERR                        ( T -> :: SIZEERR ;     )
                                   ( F -> :: <ob> <rest> ; )
caseTRUE                           ( T -> T                 )
                                   ( F -> :: <ob1> <rest> ; )
CCSB1                              Uses D.S to set SB, clears carry
CDR$                               ( $ -> $' )
CDRCOMP                            (      comp -> comp-ob_head )
                                   ( comp_null -> comp_null    )
xCEIL                              ( x -> n )
CENTER$3x5                         ( grob #x #y $ #w -> grob' )
xCENTR                             ( (x,y) ->  )
                                   (     x ->  )
xCF                                ( n ->  )
cfC                                1
cfF                                0.555...
CHANGETYPE                         ( ob #prolog -> ob' )
char                               111d 6Fh
CHECKHEIGHT                        ( grob #height ->  )
CHECKKEY                           (  -> #kc T )
                                   (  -> F     )
CHECKMENU                          (  ->  )
CheckMenuRow                       ( # -> # #' )
CHECKPICT                          (  ->  )
CHECKPVARS                         (  -> {} )
~Choose                            ( ::Appl $Title ::Convert {} offset -> {}' T )
                                   ( ::Appl $Title ::Convert {} offset -> ob T  )
                                   ( ::Appl $Title ::Convert {} offset -> F     )
~ChooseMenu0                       (  -> {} )
~ChooseMenu1                       (  -> {} )
~ChooseMenu2                       (  -> {} )
~ChooseSimple                      ( $title {items} -> ob T )
                                   ( $title {items} -> F    )
xCHR                               ( n -> $ )
CHR>#                              ( chr -> # )
CHR>$                              ( chr -> $* Strings )
CHR_#                              '#',   CHR  35d 23h
CHR_*                              '*',   CHR  42d 2Ah
CHR_+                              '+',   CHR  43d 2Bh
CHR_,                              ',',   CHR  44d 2Ch
CHR_-                              '-',   CHR  45d 2Dh
CHR_->                             '->', CHR 141d 8Dh
CHR_.                              '.',   CHR  46d 2Eh
CHR_...                            '...', CHR  31d 1Fh
CHR_/                              '/',   CHR  47d 2Fh
CHR_0                              '0',   CHR  48d 30h
CHR_00                             '\00', CHR   0d 00h
CHR_1                              '1',   CHR  49d 31h
CHR_2                              '2',   CHR  50d 32h
CHR_3                              '3',   CHR  51d 33h
CHR_4                              '4',   CHR  52d 34h
CHR_5                              '5',   CHR  53d 35h
CHR_6                              '6',   CHR  54d 36h
CHR_7                              '7',   CHR  55d 37h
CHR_8                              '8',   CHR  56d 38h
CHR_9                              '9',   CHR  57d 39h
CHR_:                              ':',   CHR  58d 3Ah
CHR_;                              ';',   CHR  59d 3Bh
CHR_<                              '<',   CHR  60d 3Ch
CHR_<<                             '®', CHR 171d ABh
CHR_<=                             'ó', CHR 137d 89h
CHR_<>                             '<>', CHR 139d 8Bh
CHR_=                              '=',   CHR  61d 3Dh
CHR_>                              '>',   CHR  62d 3Eh
CHR_>=                             'ò', CHR 138d 8Ah
CHR_>>                             '¯', CHR 187d BBh
CHR_[                              '[',   CHR  91d 5Bh
CHR_]                              ']',   CHR  93d 5Dh
CHR_A                              'A',   CHR  65d 41h
CHR_a                              'a',   CHR  97d 61h
CHR_Angle                          '', CHR 128d 80h
CHR_b                              'b',   CHR  98d 62h
CHR_B                              'B',   CHR  66d 42h
CHR_C                              'C',   CHR  67d 43h
CHR_c                              'c',   CHR  99d 63h
CHR_D                              'D',   CHR  68d 44h
CHR_d                              'd',   CHR 100d 64h
CHR_DblQuote                       '"',   CHR  34d 22h
CHR_Deriv                          'ë', CHR 136d 88h
CHR_e                              'e',   CHR 101d 65h
CHR_E                              'E',   CHR  69d 45h
CHR_F                              'F',   CHR  70d 46h
CHR_f                              'f',   CHR 102d 66h
CHR_G                              'G',   CHR  71d 47h
CHR_g                              'g',   CHR 103d 67h
CHR_h                              'h',   CHR 104d 68h
CHR_H                              'H',   CHR  72d 48h
CHR_I                              'I',   CHR  73d 49h
CHR_i                              'i',   CHR 105d 69h
CHR_Integral                       'ô', CHR 132d 84h
CHR_j                              'j',   CHR 106d 6Ah
CHR_J                              'J',   CHR  74d 4Ah
CHR_K                              'K',   CHR  75d 4Bh
CHR_k                              'k',   CHR 107d 6Bh
CHR_L                              'L',   CHR  76d 4Ch
CHR_l                              'l',   CHR 108d 6Ch
CHR_LeftPar                        '(',   CHR  40d 28h
CHR_m                              'm',   CHR 109d 5Dh
CHR_M                              'M',   CHR  77d 4Dh
CHR_N                              'N',   CHR  78d 4Eh
CHR_n                              'n',   CHR 110d 6Eh
CHR_Newline                        '\0a', CHR  10d 0Ah
CHR_O                              'O',   CHR  79d 4Fh
CHR_o                              'o',   CHR 111d 6Fh
CHR_P                              'P',   CHR  80d 50h
CHR_p                              'p',   CHR 112d 70h
CHR_Pi                             'ã', CHR 135d 87h
CHR_Q                              'Q',   CHR  81d 51h
CHR_q                              'q',   CHR 113d 71h
CHR_r                              'r',   CHR 114d 72h
CHR_R                              'R',   CHR  82d 52h
CHR_RightPar                       ')',   CHR  41d 29h
CHR_s                              's',   CHR 115d 73h
CHR_S                              'S',   CHR  83d 53h
CHR_Sigma                          'ä', CHR 133d 85h
CHR_Space                          ' ',  CHR  32d 20h
CHR_T                              'T',   CHR  84d 54h
CHR_t                              't',   CHR 116d 74h
CHR_U                              'U',   CHR  85d 55h
CHR_u                              'u',   CHR 117d 75h
CHR_UndScore                       '_',   CHR  95d 5Fh
CHR_V                              'V',   CHR  86d 56h
CHR_v                              'v',   CHR 118d 76h
CHR_w                              'w',   CHR 119d 77h
CHR_W                              'W',   CHR  87d 57h
CHR_X                              'X',   CHR  88d 58h
CHR_x                              'x',   CHR 120d 78h
CHR_Y                              'Y',   CHR  89d 59h
CHR_y                              'y',   CHR 121d 79h
CHR_z                              'z',   CHR 122d 7Ah
CHR_Z                              'Z',   CHR  90d 5Ah
CHR_{                              '{',   CHR 123d 7Bh
CHR_}                              '{',   CHR 125d 7Dh
CINRTN                             C=IN see also <see>AINRTN
                                   For hardware reasons (bug)
                                   C=IN must be at even addr
(CK%ACOS)                          ( % -> ACOS% )
(CK%ACOSH)                         ( % -> ACOSH% )
(CK%ASIN)                          ( % -> ASIN% )
(CK%ATANH)                         ( % -> ATANH% )
(CK%LN)                            ( % -> LN% )
(CK%LOG)                           ( % -> LOG% )
(CK%SQRT)                          ( % -> û%% )
(Ck&AsnUKeys)                      ( {} ->  )
(Ck&ClrUKey)                       (     0 ->  )
                                   ( %rc.p ->  )
Ck&DecKeyLoc                       ( %rc.p -> #kc #p )
CK&DISPATCH0                       (  ->  )
CK&DISPATCH1                       (  ->  )
CK&DISPATCH2                       (  ->  )
^Ck&DoMsgBox                       ( $ #x #y grob menu -> T )
Ck&Freeze                          ( % ->  )
CK0                                (  ->  )
CK0ATTNABORT                       (  ->  )
CK0NOLASTWD                        (  ->  )
CK1                                ( ob -> ob )
CK1&Dispatch                       (  ->  )
CK1NoBlame                         (  ->  )
CK1NOLASTWD                        ( ob -> ob )
CK2                                ( ob1 ob2 -> ob1 ob2 )
CK2&Dispatch                       (  ->  )
CK2NOLASTWD                        ( ob1 ob2 -> ob1 ob2 )
CK3                                ( ob1...ob3 -> ob1...ob3 )
CK3&Dispatch                       (  ->  )
CK3NOLASTWD                        ( ob1...ob3 -> ob1...ob3 )
CK4                                ( ob1...ob5 -> ob1...ob5 )
CK4&Dispatch                       (  ->  )
CK4NOLASTWD                        ( ob1...ob4 -> ob1...ob4 )
CK5                                ( ob1...ob5 -> ob1...ob5 )
CK5&Dispatch                       (  ->  )
CK5NOLASTWD                        ( ob1...ob5 -> ob1...ob5 )
(CKARRY)                           (  ->  )
(CKCARRY)                          (  ->  )
CkChr00                            ( $ -> $ flag )
(ckevaleq1)                        ( meta&= -> sym )
CKGROBFITS                         ( g1 g2 #n #m -> g1 g2' #n #m )
CKINFARGS                          (  ->  )
CKLBCRC                            Check CRC of library at D0
                                   CC: Ok  CS: CRC is wrong
                                   Uses A.A C.W D0 P
(CKLIST)                           (  ->  )
(CKLISTTYPE)                       (  ->  )
CKN                                ( ob1...obn %n -> ob1..obn #n )
(CKNAMELIST)                       (  ->  )
(CKNFLOATS)                        (  ->  )
CKNNOLASTWD                        ( ob1...obn %n -> ob1..obn #n )
(CkNonNull)                        ( ob -> ob T )
                                   ( ob -> F    )
(cknseval:)                        ( % sym -> symf )
(cknum2:)                          ( symf symf -> symf )
cknumdsptch1                       ( sym -> symf )
CKPICT                             ( xPICT ->  )
(CKRARRY)                          (  ->  )
CKREAL                             ( % -> % )
                                   ( Z -> % )
CKREF                              ( ob -> ob' )
(ckseval1:)                        ( symf' -> symf' )
xCKSM                              ( n_type ->  )
(cksneval2:)                       ( sym % -> symf )
(cksseval2:)                       ( sym sym -> symf )
(CKSYMBN)                          ( meta -> ob )
CKSYMBTYPE                         (  ->  )
(CKWHEREARGS)                      checks pairs of quoted names
CLCD10                             (  ->  )
(Clean$)                           Shrink strobj in top of TEMPOB
                                   R1=addr of length field
                                   A.A=new end address
                                   Uses A.W B.A C.W D.A D0 D1
(Clean$R0)                         R1=R0+5 <see>Clean$
xCLEAR                             ( ob1 .. obn ->  )
CLEARLCD                           (  ->  )
CLEARMENU                          (  ->  )
CLEARVDISP                         (  ->  )
(CLKADJ)                           ( %time ->  )
xCLKADJ                            ( ticks ->  )
clkspd                             Measure CPU clock speed
                                   Interrupts off on entry and exit
                                   -> A.A=spd/16 B.A=loops/16s
                                   Uses C.A D0 P CRY
CLKTICKS                           (  -> hxs )
xCLLCD                             (  ->  )
xCLOSEIO                           (  ->  )
CLOSEUART                          (  ->  )
Clr16                              (  ->  )
Clr8                               (  ->  )
Clr8-15                            (  ->  )
ClrAlgEntry                        (  ->  )
ClrAlphaAnn                        (  ->  )
(ClrAppError)                      (  ->  )
ClrAppMode                         (  ->  )
ClrAppSuspOK                       (  ->  )
(ClrBusyAnn)                       (  ->  )
ClrDA1Bad                          (  ->  )
ClrDA1IsStat                       (  ->  )
(ClrDA1NoCh)                       (  ->  )
ClrDA1OK                           (  ->  )
(ClrDA1TempF)                      (  ->  )
(ClrDA1ValidF)                     (  ->  )
ClrDA2aBad                         (  ->  )
ClrDA2aOK                          (  ->  )
(ClrDA2aTempF)                     (  ->  )
(ClrDA2aValidF)                    (  ->  )
ClrDA2bBad                         (  ->  )
(ClrDA2bEdit)                      (  ->  )
(ClrDA2bIsEdL)                     (  ->  )
(ClrDA2bNoCh)                      (  ->  )
ClrDA2bOK                          (  ->  )
(ClrDA2bTemp)                      (  ->  )
(ClrDA2bTempF)                     (  ->  )
(ClrDA2bValidF)                    (  ->  )
(ClrDA2NoCh)                       (  ->  )
ClrDA2OK                           (  ->  )
ClrDA3Bad                          (  ->  )
(ClrDA3NoCh)                       (  ->  )
ClrDA3OK                           (  ->  )
(ClrDA3TempF)                      (  ->  )
(ClrDA3ValidF)                     (  ->  )
ClrDAsOK                           (  ->  )
(ClrDoStdKeys)                     (  ->  )
ClrLeftAnn                         (  ->  )
(ClrLock)                          (  ->  )
(ClrNAppKeyOK)                     (  ->  )
ClrNoRollDA2                       (  ->  )
(CLRNUM)                           (  ->  )
(ClrNUsrKeyOK)                     (  ->  )
(ClrPrgmEntry)                     (  ->  )
ClrRightAnn                        (  ->  )
ClrSysFlag                         ( # ->  )
ClrUserFlag                        ( # ->  )
(ClrUserKeys)                      (  ->  )
xCLSIGMA                           (  ->  )
                                   UserRPL: xCLä
xCLUSR                             (  ->  )
                                   UserRPL: xCLVAR
CMDSTO                             ( $ ->  )
cmp                                2d 2h
(CMPOBOB)                          512d 200h
xCNRM                              ( [] -> col_norm )
CodePl>%rc.p                       ( #kc #p -> %rc.p )
COERCE                             ( % -> # )
COERCE$22                          ( $ -> $' )
COERCE2                            ( % %' -> # #' )
COERCEDUP                          ( % -> # # )
COERCEFLAG                         ( T -> %1 )
                                   ( F -> %0 )
COERCESWAP                         ( ob % -> # ob )
(COERCE{}2)                        ( {%} -> {#} )
COLA                               Evals next obj and
                                   drops rest of this stream.
COLA_EVAL                          Returns and evals first obj
                                   in previous stream.
COLAcase                           ( T -> :: <ob1> ;        )
                                   ( F -> :: <ob2> <rest> ; )
COLACOLA                           Drops rest of current stream
                                   does COLA in the above one.
COLAITE                            ( T -> :: <ob1> ; )
                                   ( F -> :: <ob2> ; )
(COLAkeep1st)                      ( meta&ob -> ob )
COLANOTcase                        ( T -> :: <ob2> <rest> ; )
                                   ( F -> :: <ob1> ;        )
COLARPITE                          ( T ob1 ob2 -> :: ob1 ; )
                                   ( F ob1 ob2 -> :: ob2 ; )
COLASKIP                           Drops rest of current stream
                                   and skips one obj in above stream.
(COLAskipcola)                     Drops rest of current stream,
                                   skipcola in the above.
(COLATRUE)                         (  -> T )
(colct)                            ( symf -> symf )
xCOLCT                             ( symb -> symb' )
(coleval)                          ( ob -> ob' )
(colfac)                           ( meta1 meta2 -> meta' )
(colinv1)                          ( [expr1 INV expr2 INV *] -> [expr1 expr2 /] )
(colinv2)                          ( [expr INV *] -> [expr /] )
(colinv3)                          ( [expr1 INV expr2 *] -> [expr1 expr2 /] )
(colrev)                           ( meta1 meta2 -> meta' )
(colunfac)                         ( meta1 meta2 -> meta' )
xCOMB                              ( n k -> Cn,k )
COMPEVAL                           ( comp ->  )
(COMPILEID)                        ( id -> id T     )
                                   ( id -> ROMPTR T )
                                   ( id -> F        )
COMPN                              ( obn..ob1 #n #prolog -> comp )
xCON                               (   { n } x -> []   )
                                   ( { n k } x -> [[]] )
                                   (      [] x -> []'  )
xCONIC                             (  ->  )
xCONJ                              ( x -> x' )
Connecting                         3082d C0Ah
xCONSTANTe                         (  -> e )
                                   UserRPL: xe
constuniterr                       "Inconsistent Units"
(CONSTUNITERR)                     Error B02h
xCONT                              (  ->  )
CONTEXT!                           ( rrp ->  )
CONTEXT@                           (  -> rrp )
(CONTRAST)                         5 bit value for contrast.
                                   [CON3 CON2 CON1 CON0]
xCONVERT                           ( x1_u1 x2_u2 -> x3_u2 )
xCORR                              (  -> x_correlation )
xCOS                               ( x -> x' )
xCOSH                              ( x -> x' )
(count*)                           (          meta -> meta #0 )
                                   ( meta &*&*..&* -> meta #n )
(count+)                           (          meta -> meta #0 )
                                   ( meta &+&+..&+ -> meta #n )
xCOV                               (  -> x_covariance )
xCR                                (  ->  )
(Cr)                               ob1..obn #n -> symb
CRC                                4 nibbles for CRC.
                                   Every memory fetch updates CRC.
xCRDIR                             ( name ->  )
CREATE                             ( ob id ->  )
CREATEDIR                          ( id ->  )
(CREATERRP)                        ( id ->  )
CREATETEMP                         Allocates C.A nibbles
                                   carry if not enough memory
                                   -> D0=bottom, D1=top of area
                                   -> B.A = C.A = @D1 = offset
                                   to previous tempob = #nibbles+6
CRLF$                              "\0d\0a"
xCROSS                             ( [1] [2] -> [3] )
CROSSGROB                          (  -> grob )
CRUNCH                             ( ob -> % )
CSLW5                              CSL.W 5 times
CSRW5                              CSR.W 5 times
(CUREQ)                            ID EQ
CURSOR1                            (  -> grob )
CURSOR2                            (  -> grob )
(CURSOR@)                          (  -> # )
CURSOR_END?                        (  -> flag )
CURSOR_OFF                         (  -> # )
(CURSOR_OFF+)                      (  ->  )
(CURSOR_OFF0)                      (  ->  )
D0->Row1                           ( --> D0 )
                                   Gets addr of current display
D0->Sft1                           ( --> D0 )
                                   Gets address of menu grob
D0=DSKTOP                          Get new D0 from DSKTOP, uses A
D1=DSKTOP                          Get new D1 from DSKTOP, uses C
xD>R                               ( x -> (ã/180)x )
                                   UserRPL: xD->R
(DA1Bad?)                          (  -> flag )
(DA1IsStat?)                       (  -> flag )
(DA1IsStatus?)                     (  -> flag )
(DA1NoCh?)                         (  -> flag )
DA1OK?                             (  -> flag )
DA1OK?NOTIT                        (  ->  )
(DA1TempF)                         (  ->  )
(DA1ValidF?)                       (  -> flag )
DA2aBad?                           (  -> flag )
DA2aLess1OK?                       (  -> flag )
(DA2aNoCh?)                        (  -> flag )
(DA2aOK?)                          (  -> flag )
DA2aOK?NOTIT                       (  ->  )
(DA2aTempF?)                       (  -> flag )
(DA2aValidF?)                      (  -> flag )
(DA2bBad?)                         (  -> flag )
(DA2bEdit?)                        (  -> flag )
(DA2bIsEdL?)                       (  -> flag )
DA2bNoCh?                          (  -> flag )
(DA2bOK?)                          (  -> flag )
DA2bOK?NOTIT                       (  ->  )
(DA2bTempF?)                       (  -> flag )
(DA2bValidF?)                      (  -> flag )
(DA2OK?)                           (  -> flag )
(DA3Bad?)                          (  -> flag )
(DA3NoCh?)                         (  -> flag )
DA3OK?                             (  -> flag )
DA3OK?NOTIT                        (  ->  )
(DA3TempF?)                        (  -> flag )
(DA3ValidF?)                       (  -> flag )
dARRYcase                          ( [] -> :: [] <ob1> ;        )
                                   ( ob -> :: ob <ob2> <rest> ; )
(DAsBad?)                          (  -> flag )
(DAsOK?)                           (  -> flag )
DATE                               (  -> %date )
xDATE                              (  -> date )
xDATE+                             ( date ndays -> date' )
DATE+DAYS                          ( %date %days -> %date' )
(Date+Time)                        ( hxs_d hxs_t -> hxs )
Date>d$                            ( %date -> $ )
Date>hxs13                         ( %date -> hxs )
(Date>wd$)                         ( %date -> $weekday )
(xDBUG)                            ( prog ->  )
                                   ( name ->  )
DCHXW                              Converts BCD in C.W to hex in
                                   A.W B.W C.W. See <see>HXDCW
                                   Uses P CRY
DcompWidth@                        (  -> # )
DDAYS                              ( %date1 %date2 -> %days )
xDDAYS                             ( date1 date2 -> days )
Debounce                           Scans keyboard until no more
                                   instabilities detected
                                   returns a map of the pressed keys
                                   in A.W
xDEC                               (  ->  )
DECOMP$                            ( ob -> $ )
xDECR                              ( name -> x_new )
DeepSleep                          Puts calc into "deep sleep"
                                   Low power mode, display off
                                   Wakeup on ON key or interrupt
DEEPSLEEP                          (  -> flag )
xDEFINE                            (                    'name=expr' ->  )
                                   ( 'name(name1...)=expr(name1...) ->  )
xDEG                               (  ->  )
(DEG?)                             (  -> flag )
xDELALARM                          ( n ->  )
(DELALARM)                         ( %n ->  )
xDELAY                             ( x_delay ->  )
(DelKey)                           ( #kc #plane ->  )
xDELKEYS                           ( rc.p ->  )
                                   (    0 ->  )
                                   (  'S' ->  )
xDEPND                             (         name ->  )
                                   ( {name y1 y2} ->  )
                                   (      {y1 y2} ->  )
                                   (        y1 y2 ->  )
DEPTH                              ( 1..n -> 1..n #n )
xDEPTH                             (  -> n )
xDET                               ( [[]] -> x )
xDETACH                            (       n ->  )
                                   ( :port:n ->  )
dIDNTNcase                         ( id -> :: id <ob2> <rest> ; )
                                   ( ob -> :: ob <ob1> ;        )
DIMLIMITS                          ( [] -> {#n #m} )
(DIRARGERR)                        Error 12Ah
(DirLabel:)                        (  -> grob )
(DirLabelGrob)                     21x8 directory menu key
DisableIntr                        Disable interrupts.
xDISP                              ( obj n_line ->  )
Disp5x7                            ( $ #start #max ->  )
DISP@01                            ( $ ->  )
DISP@09                            ( $ ->  )
DISP@17                            ( $ ->  )
DISP@25                            ( $ ->  )
(DISPADDR)                         Display start address
                                   write-only
(DispBadToken)                     ( ob $parsed #pos $' ->  )
DispCoord1                         ( $ ->  )
DISPCOORD2                         ( $ ->  )
DispEditLine                       (  ->  )
DispILPrompt                       (  ->  )
(DISPIO)                           Display bit offset for
                                   scrolling and DON (display on)
DispMenu                           (  ->  )
DispMenu                           (  ->  )
DispMenu.1                         (  ->  )
DispMenu.1                         (  ->  )
DISPN                              ( $ #row ->  )
DispOff                            Turns display off <see>Dispon
DispOn                             Turns display on <see>Dispoff
DISPROW1                           ( $ ->  )
DISPROW1*                          ( $ ->  )
DISPROW1*!                         ( $ ->  )
DISPROW2                           ( $ ->  )
DISPROW2*                          ( $ ->  )
DISPROW3                           ( $ ->  )
DISPROW4                           ( $ ->  )
DISPROW5                           ( $ ->  )
DISPROW6                           ( $ ->  )
DISPROW7                           ( $ ->  )
DISPROW8                           ( $ ->  )
DispStatus                         (  ->  )
DISPSTATUS2                        ( $ ->  )
DispStsBound                       (  ->  )
(DISPTEST)                         High bit of contrast and
                                   display test bits.      
DispTimeReq?                       (  -> flag )
DIV5                               C.A = C.A/5
                                   Uses A.10 C.10 D.10 P
DIVF                               x=x/y
dLISTcase                          ( {} -> :: {} ob1 ;          )
                                   ( ob -> :: ob <ob2> <rest> ; )
(DNOTBAKcase)                      ( bak -> :: bak <ob2> <rest> ; )
                                   (  ob -> :: ob <ob1> ;         )
(DNOTLIBcase)                      ( lib -> :: lib <ob2> <rest> ; )
                                   (  ob -> :: ob <ob1> ;         )
(DNOTSYMB?SEMI)                    ( symb -> :: symb <ob1> <rest> ; )
                                   (   ob -> :: ob ;                )
DO                                 ( #stop #start ->  )
xDO                                (  ->  )
DO#EXIT                            ( # ->  )
DO$EXIT                            ( $ ->  )
DO%EXIT                            ( % ->  )
(Do1st/1st+:)                      (  -> :: ob1 ; (PRG mode)         )
                                   (  -> :: ob1 <rest> (no PRG mode) )
Do1st/2nd+:                        (  -> :: <ob1> ; (PRG mode)           )
                                   (  -> :: <ob2> <rest> ; (no PRG mode) )
DO>LCD                             ( grob ->  )
DO>STR                             (  $ -> $ )
                                   ( ob -> $ )
(DOADJ)                            ( ob1 ob2 -> ob1 ob' )
(DOADJ1)                           ( ob1 ob2 -> ob1 ob' )
^DoAlert                           ( $ ->  )
(DOAPWL)                           (  ->  )
DOARRY                             Array prologue
                                   5  size
                                   5  prologue of objects
                                   5  # of dimensions
                                   5n dimensions
                                   .. objects (content only)
(DOARRY>)                          ( [] -> F%..F% {#n #m} )
(DOARRYPRG1)                       ( seco [F%] -> [F%]' )
(DOARRYPRG2)                       ( seco [F%] [F%] -> [F%]' )
DoBadKey                           (  ->  )
DOBAK                              Backup prologue
                                   5  size
                                   2  # of chars in name
                                   .. name
                                   .. object
                                   5  DOBINT
                                   5  CRC
DOBAUD                             ( % ->  )
DOBEEP                             ( %freq %dur ->  )
DOBIN                              (  ->  )
DOBIND                             ( obn..ob1 lamn..lam1 #n ->  )
DOBINT                             BINT prologue
                                   5  number (hex)
DOBUFLEN                           (  -> % 0/1 )
DOC>PX                             ( C% -> { hxs hxs' } )
DOCHAR                             Character prologue
                                   2  character
DOCHR                              ( % -> $ )
(^DoCKeyCancel)                    (  ->  )
(^DoCKeyChAll)                     (  ->  )
(^DoCKeyCheck)                     (  ->  )
(^DoCKeyOK)                        (  ->  )
(^DoCKeyUnChAll)                   (  ->  )
DOCLLCD                            (  ->  )
DOCMP                              Complex number prologue
                                   3  real exponent
                                   12 real mantissa
                                   1  real sign
                                   3  complex exponent
                                   12 complex mantissa
                                   1  complex sign
DOCODE                             Code prologue
                                   5  length
                                   .. machine code
DOCOL                              Secondary prologue
                                   .. objects
                                   5  SEMI
(docola)                           Exit to rpl COLA
DOCR                               (  ->  )
DoCRC                              Calculates the CRC of A.A nibs
                                   at D0. Returns CRC in A.A
                                   Uses C.W P
DoCRCc                             D0=C <see>DoCRC
DOCSTR                             String prologue
                                   5  length
                                   .. characters
DODEC                              (  ->  )
DODELAY                            ( % ->  )
DoDelim                            (  ->  )
DoDelims                           (  ->  )
(DODIRPRG)                         ( ob :: -> {} )
DODISP                             ( ob %row ->  )
DOECMP                             Long complex prologue
                                   5  real exponent
                                   15 real mantissa
                                   1  real sign
                                   5  complex exponent
                                   15 complex mantissa
                                   1  complex sign
DOENG                              ( # ->  )
DOERASE                            (  ->  )
DOEREL                             Long real prologue
                                   5  exponent
                                   15 mantissa
                                   1  sign
xDOERR                             ( n ->  )
                                   ( $ ->  )
                                   ( 0 ->  )
DOEXT                              Unit object prologue
                                   .. object (usually a real)
                                   .. unit
                                   5  SEMI
DOFALSE                            Push FALSE, Loop
DOFINISH                           (  ->  )
DoFirstRow                         (  ->  )
DOFIX                              ( # ->  )
DOGARBAGE                          If ST=1 10 then <see>GPMEMERR
                                   else <see>GARBAGECOL
                                   and <see>GETPTR
DOGRAPHIC                          (  ->  )
DOGROB                             GROB prologue
                                   5  size
                                   5  height
                                   5  width
DoHere:                            (  ->  )
DOHEX                              (  ->  )
DOHSTR                             HXS prologue
                                   5  length
                                   .. hex digits, reverse order
DOHXS                              HXS prologue
                                   5  length
                                   .. hex digits, reverse order
(DOHXSEXIT)                        ( hxs ->  )
DOIDNT                             Global name (ID) prologue
                                   2  # of characters
                                   .. characters
DoInputForm                        ( l1..ln f1..fm #n #m msg $ -> ob1..obn T )
                                   ( l1..ln f1..fm #n #m msg $ -> F          )
                                   l = $ #x #y
                                   f = msg #x #y #w #h #type legal
                                   dec $hlp ChDat ChDec res init
DOKERRM                            (  -> $ )
DoKeyOb                            ( ob ->  )
DoLabel                            ( #col ob ->  )
DoLabel                            ( #col ob ->  )
(DoLam)                            ( lam -> ob      )
                                   ( lam -> !error! )
DOLAM                              Local name (LAM) prologue
                                   see <see>DOIDNT
DOLCD>                             (  -> grob )
DOLIB                              Library prologue
DOLIST                             List prologue
                                   see <see>DOCOL
DOLNKARRY                          Linked array prologue
DOMEMERR                           Insufficient Memory error
DoMenuKey                          ( menu ->  )
DoMenuKeyNS                        ( #n ->  )
(DONUM)                            ( $ -> CHR )
DOOCT                              (  ->  )
DOPARITY                           ( % ->  )
DOPKT                              ( $ $' ->  )
DOPX>C                             ( { hxs hxs' } -> C% )
DORANDOMIZE                        ( % ->  )
DORCLE                             (  -> ob )
DOREAL                             Real number prologue
                                   3  exponent
                                   12 mantissa
                                   1  sign
(DORECN)                           ( $/id/lam ->  )
DOROMP                             XLIB prologue
                                   3  library ID
                                   3  command #
(DOROMPOLL)                        ( {#libnum1 #libnum2..} ->  )
DORRP                              Directory prologue
DOSBRK                             (  ->  )
DOSCI                              ( # ->  )
DOSIZEERR                          Bad Argument Value error
(doskip)                           Exit to rpl SKIP
DoSolvrMenu                        (  ->  )
DOSRECV                            ( % ->  )
DOSTD                              (  ->  )
(DoStdKeys?)                       (  -> flag )
DOSTOALLF0                         ( {} ->  )
DOSTOE                             ( ob ->  )
DOSTOSYSF                          ( hxs ->  )
DOSTR>                             ( $ -> ? )
dostws                             ( # ->  )
DOSYMB                             Symbolic prologue
                                   .. objects
                                   5  SEMI
xDOT                               ( [1] [2] -> x )
DOTAG                              Tagged object prologue
                                   2  # of chars in tag
                                   .. tag
                                   .. object
DOTRANSIO                          ( % ->  )
DOTRUE                             Push TRUE, Loop
DOTVARS%                           ( % -> {} )
DOVARS                             (  -> {id1 id2..} )
dowait                             ( %secs ->  )
(dowait/quit?)                     ( %secs ->  )
DoWarning                          ( $ ->  )
(DOXMIT)                           ( $ ->  )
DPRADIX?                           (  -> flag )
xDRAW                              (  ->  )
DRAWBOX#                           ( #x1 #y1 #x2 #y2 ->  )
DRAWLINE#3                         ( #x1 #y1 #x2 #y2 ->  )
xDRAX                              (  ->  )
dREALNcase                         (  % -> :: % <ob2> <rest> ; )
                                   ( ob -> :: ob <ob1> ;       )
xDROP                              ( ob ->  )
DROP                               ( 1 ->  )
DROP#1-                            ( # ob -> #-1 )
(DROP%0)                           ( ob -> %0 )
(DROP%0ABND)                       ( ob -> %0 )
(DROP%1)                           ( ob -> %1 )
(DROP%1ABND)                       ( ob -> %1 )
DROP'                              ( ob -> nob )
xDROP2                             ( ob1 ob2 ->  )
(DROP2dropf)                       ( meta1 meta2 ob -> F )
(DROP3PICK)                        ( 1 2 3 4 -> 1 2 3 1 )
(dropaddoper)                      ( meta1 meta2 meta3 -> meta1&meta2&LAM1 )
DropBadKey                         ( ob ->  )
DROPDEADTRUE                       ( ob -> DoBadKey T )
(dropDROPf)                        ( ob meta -> F )
DROPDUP                            ( 1 2 -> 1 1 )
(DROPDUPLEN$1+)                    ( $ ob -> $ #len+1 )
DROPFALSE                          ( ob -> F )
DROPLOOP                           ( ob ->  )
DropLoop                           Pop stack, Loop
xDROPN                             ( ob1...obn n ->  )
DROPNDROP                          ( meta ob ->  )
DROPNDROP                          ( 1..n #n ob ->  )
DROPNULL$                          ( ob -> NULL$ )
DROPONE                            ( ob -> #1 )
DROPOVER                           ( 1 2 3 -> 1 2 1 )
DROPRDROP                          ( ob ->  )
(DropRepl0)                        ( meta ob -> %0 #1 )
DROPROT                            ( 1 2 3 4 -> 2 3 1 )
DROPSWAP                           ( 1 2 3 -> 2 1 )
DROPSWAPDROP                       ( 1 2 3 -> 2 )
DROPSWAPDROP                       ( 1 2 3 -> 2 )
(DROPSYM)                          ( ob1 ob2 -> ob )
DROPTRUE                           ( ob -> T )
DROPZERO                           ( ob -> #0 )
(DRPExitAtLOOP)                    ( ob ->  )
(drpmeta*)                         ( meta&INV&ob -> meta&/ )
                                   (     meta&ob -> meta&* )
(drpmeta+)                         ( meta&NEG&ob -> meta&- )
                                   (     meta&ob -> meta&+ )
(drpmeta-)                         ( meta&NEG&ob -> meta&+ )
                                   (     meta&ob -> meta&- )
(drpmeta/)                         ( meta&INV&ob -> meta&* )
                                   (     meta&ob -> meta&/ )
(drppargsym)                       ( meta&ob -> 'M_rest''MetaLast' )
(drppargtop&)                      ( meta&ob -> M_last&M_rest )
xDTAG                              ( tag:obj -> obj )
DTYPEARRY?                         ( ob -> ob flag )
DTYPECOL?                          ( ob -> ob flag )
DTYPECSTR?                         ( ob -> ob flag )
DTYPELIST?                         ( ob -> ob flag )
DTYPEREAL?                         ( ob -> ob flag )
DUMP                               ( NULLLAM -> ob1..obn #n )
DUP                                ( ob -> ob ob )
xDUP                               ( ob -> ob ob )
(dup)                              ( meta -> meta meta )
DUP#0<>                            ( # -> # flag )
DUP#0<>WHILE                       ( # ->  )
DUP#0=                             ( # -> # flag )
DUP#0=case                         ( #0 -> :: #0 <ob1> ;       )
                                   (  # -> :: # <ob2> <rest> ; )
DUP#0=csDROP                       ( #0 -> :: ;                )
                                   (  # -> :: # <ob1> <rest> ; )
DUP#0=csedrp                       ( #0 -> :: <ob1> ;          )
                                   (  # -> :: # <ob2> <rest> ; )
DUP#0=IT                           ( #0 -> :: #0 <ob1> <rest> ; )
                                   (  # -> :: # <ob2> <rest> ;  )
DUP#0=ITE                          ( #0 -> :: #0 <ob1> <ob3> <rest> ; )
                                   (  # -> :: # <ob2> <rest> ;        )
DUP#0_DO                           ( #stop -> #stop )
DUP#1+                             ( # -> # #+1 )
DUP#1+PICK                         ( ob&meta -> ob&meta ob )
DUP#1+PICK                         ( n..1 #n -> n..1 #n n )
DUP#1-                             ( # -> # #-1 )
DUP#1=                             ( # -> # flag )
DUP#2+                             ( # -> # #+2 )
(DUP#2+PICK)                       ( n..1 #n -> n..1 #n n+1 )
DUP#<7                             ( # -> # flag )
DUP$>ID                            ( $ -> $ ID )
DUP%0=                             ( % -> flag )
(DUP%0CON)                         ( [F%] -> [F%] [0%] )
DUP'                               ( ob -> ob nob )
DUP1LAMBIND                        ( ob -> ob )
xDUP2                              ( 1 2 -> 1 2 1 2 )
DUP3PICK                           ( 1 2 -> 1 2 2 1 )
DUP3PICK                           ( 1 2 -> 1 2 2 1 )
DUP3PICK#+                         ( # #' -> # #' #+#' )
DUP4PUTLAM                         ( ob -> ob )
DUP4UNROLL                         ( 1 2 3 -> 3 1 2 3 )
DUP@                               ( id/lam -> id/lam ob T )
                                   ( id/lam -> id/lam F    )
DUPDUP                             ( ob -> ob ob ob )
DUPEQ:                             ( ob -> ob flag )
(DUPExitAtLOOP)                    ( ob -> ob ob )
DUPGROBDIM                         ( grob -> grob #height #width )
DUPINCOMP                          ( comp -> comp obn..ob1 #n )
DUPINDEX@                          ( ob -> ob # )
DUPLEN$                            ( $ -> $ # )
DUPLENCOMP                         ( comp -> comp #n )
xDUPN                              ( 1...n n -> 1...n 1...n )
DUPNULL$?                          ( ob -> ob flag )
DUPNULLCOMP?                       ( comp -> comp flag )
DUPNULL{}?                         ( {} -> {} flag )
DUPONE                             ( ob -> ob ob #1 )
DUPPICK                            ( n..1 #n -> n..1 #n n-1 )
DUPROLL                            ( 1..n #n -> 1 3..n #n 2 )
DUPROM-WORD?                       ( ob -> ob flag )
DUPROMPTR@                         ( ROMPTR -> ROMPTR ob T )
                                   ( ROMPTR -> ROMPTR F    )
DUPROT                             ( 1 2 -> 2 2 1 )
DUPSAFE@                           ( id/lam -> id/lam ob T )
                                   ( id/lam -> id/lam F    )
DUPTEMPENV                         (  ->  )
DUPTEMPEVN                         (  ->  )
DUPTWO                             ( ob -> ob ob #2 )
DUPTYPEARRY?                       ( ob -> ob flag )
DUPTYPEBINT?                       ( ob -> ob flag )
DUPTYPECHAR?                       ( ob -> ob flag )
DUPTYPECMP?                        ( ob -> ob flag )
DUPTYPECOL?                        ( ob -> ob flag )
DUPTYPECSTR?                       ( ob -> ob flag )
DUPTYPEEXT?                        ( ob -> ob flag )
DUPTYPEGROB?                       ( ob -> ob flag )
DUPTYPEHSTR?                       ( ob -> ob flag )
DUPTYPEIDNT?                       ( ob -> ob flag )
DUPTYPELAM?                        ( ob -> ob flag )
DUPTYPELIST?                       ( ob -> ob flag )
DUPTYPEREAL?                       ( ob -> ob flag )
DUPTYPEROMP?                       ( ob -> ob flag )
DUPTYPERRP?                        ( ob -> ob flag )
DUPTYPESYMB?                       ( ob -> ob flag )
DUPTYPETAG?                        ( ob -> ob flag )
DUPUNROT                           ( 1 2 -> 2 1 2 )
DUPUNROT                           ( 1 2 -> 2 1 2 )
DUPZERO                            ( ob -> ob ob #0 )
dvarlsBIND                         ( ob ->  )
(dvars>)                           ( meta -> meta' )
(dvars?)                           ( meta -> meta flag )
Echo$Key                           ( $/chr ->  )
Echo$NoChr00                       ( $ ->  )
EchoChrKey                         ( $/chr ->  )
ederr                              (  ->  )
EDITDECOMP$                        ( ob -> $ )
editdecomp$w                       ( ob -> $ )
EditExstCase                       (  -> :: <ob1> <rest> ; )
                                   (  -> :: <rest> ;       )
EditLevel1                         ( ob -> ob' )
EditLExists?                       (  -> flag )
EDITLINE$                          (  -> $ )
EditMenu                           (  -> {} )
EditString                         ( $ ->  )
EIGHT                              8d 8h
EIGHTEEN                           18d 12h
EIGHTROLL                          ( 1..8 -> 2..8 1 )
EIGHTY                             80d 50h
EIGHTYONE                          81d 51h
ELEVEN                             11d  Bh
xELSE                              (  ->  )
Embedded?                          ( ob1 ob2 -> flag )
(EMPTYDIRERR)                      Error 12Bh
xENDDO                             ( 1/0 ->  )
                                   UserRPL: xEND
xENG                               ( n ->  )
EQ                                 ( ob1 ob2 -> flag )
EQ:                                ( ob -> flag )
xEQ>                               ( 'l=r' -> l r )
                                   UserRPL: xEQ->
EQcase                             ( ob1 ob1 -> :: ob1 <ob1> ;        )
                                   ( ob1 ob2 -> :: ob1 <ob2> <rest> ; )
EQcasedrop                         ( ob1 ob1 -> :: <ob1> ;            )
                                   ( ob1 ob2 -> :: ob1 <ob2> <rest> ; )
EQIT                               ( ob1 ob1 -> :: <ob1> <rest> ; )
                                   ( ob1 ob2 -> :: <ob2> <rest> ; )
EQITE                              ( ob1 ob1 -> :: <ob1> <ob3> <rest> ; )
                                   ( ob1 ob2 -> :: <ob2> <rest> ;       )
EqList?                            ( ob ->  )
EQLookup                           ( ob comp -> nextob T )
                                   ( ob comp -> ob F     )
EQOR                               ( flag ob1 ob2 -> flag' )
EQOVER                             ( ob3 ob1 ob2 -> ob3 flag ob3 )
EQUAL                              ( ob1 ob2 -> flag )
EQUALcase                          ( ob1 ob1 -> :: <ob1> ;        )
                                   ( ob1 ob2 -> :: <ob2> <rest> ; )
EQUALcasedro                       ( ob1 ob2 -> :: <ob1> ;            )
                                   ( ob1 ob2 -> :: ob1 <ob2> <rest> ; )
EQUALcasedrop                      ( ob1 ob2 -> :: <ob1> ;            )
                                   ( ob1 ob2 -> :: ob1 <ob2> <rest> ; )
EQUALcasedrp                       ( ob ob1 ob2 -> :: <ob1> ;           )
                                   ( ob ob1 ob2 -> :: ob <ob2> <rest> ; )
EQUALNOT                           ( ob1 ob2 -> flag )
EQUALNOTcase                       ( ob1 ob1 -> :: <ob2> <rest> ; )
                                   ( ob1 ob2 -> :: <ob1> ;        )
EQUALOR                            ( flag ob1 ob2 -> flag' )
EQUALPOSCOMP                       ( comp ob -> #pos )
                                   ( comp ob -> #0   )
EQUATION                           (  -> ob )
xERASE                             (  ->  )
(Err#Cont)                         318d 13Eh
(Err#Kill)                         291d 123h
(Err#NoLstArg)                     517d 205h
(Err#NoLstStk)                     292d 124h
xERR0                              (  ->  )
(ERR0)                             (  ->  )
ERRBEEP                            (  ->  )
Errjmp                             Error exit
                                   A.A = error number
ERRJMP                             (  ->  )
ErrjmpC                            A=C.A <see>Errjmp
(ERRM)                             (  -> $ )
xERRM                              (  -> $msg )
(ERRN)                             (  -> # )
xERRN                              (  -> $nerr )
(ERRN>HXS)                         (  -> hxs )
ERROR@                             (  -> # )
ERRORCLR                           (  ->  )
ERROROUT                           ( # ->  )
ERRORSTO                           ( # ->  )
ERRSET                             (  ->  )
ERRTRAP                            (  ->  )
xEVAL                              ( ob -> ? )
EVAL                               ( ob ->  )
(eval)                             ( sym -> ? )
(evalcase:)                        ( meta -> ? )
EvalNoCK                           ( comp -> ? )
(evalTRUE)                         ( sym -> ? T )
EXAB0                              A.W <-> R0
                                   B.W <-> R1 
EXAB2                              A.W <-> R2
                                   B.W <-> R3 
ExitAtLOOP                         (  ->  )
(ExitAtLOOPDUP)                    ( ob -> ob ob )
EXITMSGSTO                         ( $ ->  )
xEXP                               ( x -> x' )
(expan)                            ( meta1 meta2 meta3 -> meta )
xEXPAN                             ( symb1 -> symb2 )
(expan1)                           ( meta -> meta1 meta2 )
EXPAND                             ( hxs #nibs -> hxs' )
EXPAND                             ( hxs #nibs -> hxs' )
xEXPFIT                            (  ->  )
(EXPLODE)                          ( ob -> meta )
xEXPM                              ( x -> x' )
(EXPR>)                            ( sym -> arg1..argn %n ob )
EXT                                14d  Eh
EXTN                               ( ob1..obn #n -> u )
EXTN                               ( ob1..obn #n -> u )
EXTOBOB                            3584d E00h
EXTREAL                            225d E1h
EXTSYM                             234d EAh
(F%>L%)                            (  % -> %%   )
                                   ( C% -> C%%  )
xFACT                              ( x -> x' )
                                   UserRPL: x!
failed                             (  -> F T )
FALSE                              (  -> F )
FALSE'                             (  -> F nob )
FalseFalse                         (  -> F F )
FALSETRUE                          (  -> F T )
FalseTrue                          (  -> F T )
(FBox/StdLbl:)                     (  -> grob )
xFC?                               ( n -> 0/1 )
xFC?C                              ( n -> 0/1 )
xferfailerr                        "Transfer Failed"
FIFTEEN                            15d  Fh
FIFTY                              50d 32h
FIFTYEIGHT                         58d 3Ah
FIFTYFIVE                          55d 37h
FIFTYFOUR                          54d 36h
FIFTYNINE                          59d 3Bh
FIFTYONE                           51d 33h
FIFTYSEVEN                         57d 39h
FIFTYSIX                           56d 38h
FIFTYTHREE                         53d 35h
FIFTYTWO                           52d 34h
Find1stTrue                        ( comp test -> ob T )
                                   ( comp test -> F    )
xFINDALARM                         (        date -> n )
                                   ( {date time} -> n )
                                   (           0 -> n )
(FINDALARM%)                       ( %date -> % )
(FINDALARMLS)                      ( {} -> % )
(FINDELN)                          ( {} A -> # flag )
(FINDVAR)                          ( sym -> {} )
xFINISH                            (  ->  )
(FIRST@LAM)                        ( lam -> ob T )
                                   ( lam -> F    )
(FIRSTC+)                          (  ->  )
(FIRSTC@)                          (  -> # )
FIVE                               5d 5h
FIVEFOUR                           84d 54h
FIVEROLL                           ( 1 2 3 4 5 -> 2 3 4 5 1 )
FIVESIX                            86d 56h
FIVETHREE                          83d 53h
FIVEUNROLL                         ( 1 2 3 4 5 -> 5 1 2 3 4 )
xFIX                               ( n ->  )
FlashMsg                           ( $ ->  )
FlashWarning                       ( $ ->  )
xFLOOR                             ( x -> n )
FLUSH                              (  ->  )
Flush                              Flushes key buffer.
FlushAttn                          Flushes attn counter.
FLUSHKEYS                          (  ->  )
(forceadd)                         ( meta -> meta' )
(forcemul)                         ( meta -> meta' )
(forcemul?aga)                     ( meta -> meta' )
FORTY                              40d 28h
FORTYEIGHT                         48d 30h
FORTYFIVE                          45d 2Dh
FORTYFOUR                          44d 2Ch
FORTYNINE                          49d 31h
FORTYONE                           41d 29h
FORTYSEVEN                         47d 2Fh
FORTYSIX                           46d 2Eh
FORTYTHREE                         43d 2Bh
FORTYTWO                           42d 2Ah
FOUR                               4d 4h
FOURFIVE                           69d 45h
FOURROLL                           ( 1 2 3 4 -> 2 3 4 1 )
FOURROLLROT                        ( 1 2 3 4 -> 2 4 1 3 )
FOURTEEN                           14d  Eh
FOURTHREE                          67d 43h
FOURTWO                            66d 42h
FOURTY                             40d 28h
FOURUNROLL                         ( 1 2 3 4 -> 4 1 2 3 )
xFP                                ( x -> x' )
(FREEINTEMP?)                      ( ob -> ob flag )
xFREEZE                            ( n ->  )
xFS?                               ( n -> 0/1 )
xFS?C                              ( n -> 0/1 )
(FStd/BoxLbl:)                     (  -> grob )
(FSTMACROROM#)                     1792d 700h
xFUNCTION                          (  ->  )
GARBAGE                            (  ->  )
GARBAGECOL                         Garbage collection
                                   does not use R1..R4
GBUFF                              (  -> graphgrob )
GBUFFGROBDIM                       (  -> #height #width )
GDISPCENTER                        (  ->  )
(GDISPON?)                         (  -> flag )
xGET                               ( ob n -> elm )
                                   ob = [] or [[]] or {} or name
                                   pos = n or {n} or {n m}
get1                               ( ob meta -> meta ob )
GETATELN                           ( # [] -> ob T )
                                   ( # [] -> F    )
(GETCONFIG)                        ( #libnum -> ob T )
                                   ( #libnum -> F    )
GETDF                              ( #menukey -> ob )
(GETEL)                            ( #i [] -> ob T )
                                   ( #i [] -> F    )
GetEqN                             ( #n -> ob T    )
                                   ( #n -> NULL$ F )
GETEXITMSG                         (  -> $ )
(GETHASH)                          ( #libnum -> hxs_table T )
                                   ( #libnum -> F           )
xGETI                              ( ob pos -> ob' pos' elm )
                                   ob = [] or [[]] or {} or name
                                   pos = n or {n} or {n m} 
GETINDEP                           (  -> id )
                                   (  -> {} )
GetIOPAR                           (  -> %baud % % % % % )
GETKEY                             (  -> #kc flag )
GETKEY*                            (  -> #kc T          )
                                   (  -> F F            )
                                   (  -> {Alrmlist} T F )
GetKeyOb                           (  -> ob )
GETLAM                             ( #n -> ob )
GETLAMPAIR                         ( #n -> #n ob lam F )
                                   ( #n -> #n T        )
(GETLINK)                          ( #libnum -> hxs_table T )
                                   ( #libnum -> F           )
getmatchtok                        ( hxs-mask $ #loc $_tok -> hxs-mask $ #next $match )
GetMenu%                           (  -> % )
(GETMSG)                           ( #libnum -> [] T )
                                   ( #libnum -> F    )
GETNAME                            ( $/id/lam ->  )
GetNextToken                       ( hxs-mask $ #start -> hxs-mask $ #next $token )
getnibs                            ( hxs hxs -> hxs' )
GETPARAM                           ( # -> ob )
GETPMIN&MAX                        (  -> C% C% )
GETPROC                            ( #menukey -> ob )
GETPTR                             <see>SAVPTR in reverse
                                   Clears Carry.
GETPTRFALSE                        <see>GETPTR , Do FALSE
GETPTRLOOP                         <see>GETPTR , Loop to RPL
GETPTRTRUE                         <see>GETPTR , Do TRUE
GETPTYPE                           (  -> name )
GETRES                             (  -> % )
(GETRRP)                           Returns the RRP in which the
                                   object at A.A lies. If ob is
                                   SysRRP, returns CS and leaves
                                   A.A unchanged; else CC and
                                   A.A->RRP B.A->RAM-WORD
                                   Uses A.A B.A C.A D.A D0
GETSCALE                           (  -> % %' )
GetStrLen                          D1=$ -> C.A = length,
                                   D1 = body
GetStrLenC                         D1 = C, <see>GetStrLen
GetStrLenStk                       Pop $ -> C.A = length, D1 = body
GETTEMP                            <see>CREATETEMP with
                                   <see>GARBAGECOL if necessary
                                   <see>GPMEMERR if not
                                   enough memory
GETTHEMESG                         ( # -> $ )
GETTOUCH                           (  -> #kc T )
                                   (  -> F     )
GetUserKeys                        (  -> {} )
(getwordsize)                      Fetches current word size to A,
                                   Clear Carry
GETXMAX                            (  -> % )
GETXMIN                            (  -> % )
GETYMAX                            (  -> % )
GETYMIN                            (  -> % )
xGOR                               ( g_targ {#n #m} grob -> g_targ' )
                                   (   g_targ (x,y) grob -> g_targ' )
                                   (        PICT ... ... ->         )
GOTO                               (  ->  )
GPErrjmpC                          A=C.A <see>GETPTR <see>Errjmp
GPMEMERR                           <see>GETPTR <see>DOMEMERR
GPOverWrALp                        <see>GETPTR , OverWr A, Loop
GPOverWrFLp                        <see>GETPTR , OverWr FALSE, Loop
GPOverWrR0Lp                       <see>GETPTR , OverWr R0, Loop
GPOverWrT/FL                       <see>GETPTR , OverWr
                                   TRUE/FALSE, Loop
GPOverWrTLp                        <see>GETPTR , OverWr TRUE, Loop
GPPushA                            <see>GETPTR , Push A, Clear Carry
GPPushFLoop                        <see>GETPTR , Push FALSE, Loop
GPPushFTLp                         <see>GETPTR , Loop to FalseTrue
GPPushT/FLp                        <see>GETPTR , Push TRUE/FALSE,
                                   Loop
GPPushTLoop                        <see>GETPTR , Push TRUE, Loop
xGRAD                              (  ->  )
xGRAPH                             (  ->  )
                                   UserRPL: xPICTURE
grob                               12d  Ch
GROB!                              ( grob1 grob2 #x #y ->  )
(grob!)                            R0,R1 = (row,col),
                                   D0 = grob1, D1 = grob2 -->
                                   Stores grob1 into grob2
GROB!ZERO                          ( grob #x1 #y1 #x2 #y2 -> grob' )
GROB!ZERODRP                       ( grob #x1 #y1 #x2 #y2 ->  )
GROB+#                             ( flag grob1 grob2 #x #y -> grob' )
GROB>GDISP                         ( grob ->  )
Grob>Menu                          ( #col grob ->  )
Grob>Menu                          ( #col grob ->  )
~grobAlertIcon                     9x9 Alert grob
~grobCheckKey                      21x8 Check Key menu grob
GROBDIM                            ( grob -> #height #width )
GROBDIMw                           ( grob -> #width )
xGXOR                              ( g_targ {#n #m} g_src -> g_targ' )
                                   (   g_targ (x,y) g_src -> g_targ' )
                                   (         PICT ... ... ->         )
H/W>KeyCode                        ( # -> #' )
xHALT                              (  ->  )
HARDBUFF                           (  -> dispgrob )
HARDBUFF2                          (  -> menugrob )
HARDHEIGHT                         (  -> #height )
HBUF_X_Y                           (  -> HBgrob #x #y )
HBUFF_X_Y                          (  -> HBgrob #x #y )
(HBUFFDIMw)                        (  -> #width )
HEIGHTENGROB                       ( grob #rows ->  )
(HEIGHTENHBUFF)                    ( #rows ->  )
xHEX                               (  ->  )
xHISTOGRAM                         (  ->  )
xHISTPLOT                          (  ->  )
xHMS+                              ( hms1 hms2 -> hms3 )
xHMS-                              ( hms1 hms2 -> hms3 )
xHMS>                              ( x -> x' )
                                   UserRPL: xHMS->
xHOME                              (  ->  )
HOMEDIR                            (  ->  )
(HrTicks)                          29491200
HXDCW                              Converts hex in A.W to BCD in
                                   A.W B.W C.W. See <see>DCHXW
                                   Uses P CRY
hxs                                11d  Bh
HXS#HXS                            ( hxs hxs' -> %flag )
HXS<=HXS                           ( hxs hxs' -> %flag )
HXS<HXS                            ( hxs hxs' -> %flag )
HXS==HXS                           ( hxs hxs' -> %flag )
HXS>#                              ( hxs -> # )
HXS>$                              ( hxs -> $ )
hxs>$                              ( hxs -> $ )
HXS>%                              ( hxs -> % )
HXS>=HXS                           ( hxs hxs' -> %flag )
HXS>HXS                            ( hxs hxs' -> %flag )
(HXSREAL)                          177d B1h
xi                                 (  -> i )
ICMPDRPRTDRP                       ( comp -> obn...ob4 ob2 ob1 )
id                                 6d 6h
ID>$                               ( id/lam -> $ )
(ID>LAM)                           ( id -> lam )
Id>Menu                            ( #col id ->  )
Id>Menu                            ( #col id ->  )
ID>TAG                             ( ob id/lam -> tagged )
(ID_CST)                           ID CST
(ID_S)                             ID S
(ID_SIGMADAT)                      ID äDAT
(ID_SKEY)                          ID SKEY
(ID_UserKeys)                      ID UserKeys
(ID_UserKeys.)                     ID UserKeys.CRC
ID_X                               ID X
ID_Y                               ID Y
(IDCONFERR)                        Error 13Ch
(IDLISTOB)                         1616d 650h
xIDN                               (    n -> [[]]  )
                                   ( [[]] -> [[]]' )
                                   ( name -> [[]]  )
idnt                               6d 6h
idntcase                           ( id -> :: id <ob1> ;        )
                                   ( ob -> :: ob <ob2> <rest> ; )
idntlamcase                        ( id/lam -> :: id <ob1> ;        )
                                   (     ob -> :: ob <ob2> <rest> ; )
IDREAL                             97d 61h
(IDREALOB)                         1552d 610h
IDUP                               (  ->  )
IDUP                               (  ->  )
xIF                                (  ->  )
xIFERR                             (  ->  )
~IFMenuRow1                        (  -> {} )
~IFMenuRow2                        (  -> {} )
xIFT                               ( 0/1 obj -> ? )
xIFTE                              ( 0/1 objT objF -> ? )
xIM                                ( (x,y) -> y   )
                                   (    [] -> []' )
ImmedEntry?                        (  -> flag )
(IMPLODE)                          ( meta -> ob )
INCOMPDROP                         ( comp -> obn..ob1 )
xINCR                              ( name -> x' )
xINDEP                             (         name ->  )
                                   ( {name x1 x2} ->  )
                                   (      {x1 x2} ->  )
                                   (        x1 x2 ->  )
INDEPVAR                           (  -> id )
INDEX@                             (  -> # )
INDEX@#-                           ( # -> #' )
INDEX@-                            ( # -> #' )
INDEXSTO                           ( # ->  )
(infarg?)                          ( seco -> seco flag )
(INFRESERR)                        Error 305h
infreserr                          "Infinite Result"
INHARDROM?                         ( ob -> ob flag )
(InitDispModes)                    (  ->  )
InitEd&Modes                       (  ->  )
InitEdLine                         (  ->  )
InitEdModes                        (  ->  )
InitMenu                           ( menu ->  )
InitMenu%                          ( %mnu.pg ->  )
                                   (      %0 ->  )
InitTrack:                         (  ->  )
INNER#1=                           ( comp -> obn..ob1 flag )
INNERCOMP                          ( comp -> obn..ob1 #n )
INNERDUP                           ( comp -> obn..ob1 #n #n )
(INNERtop&)                        ( obn..ob1 #n comp -> obm..ob1 #m )
xINPUT                             (       $prompt $ -> $' )
                                   ( $prompt {specs} -> $' )
InputLine                          ( args -> $ T          )
                                   ( args -> $ ob1..obn T )
                                   ( args -> ob1..obn T   )
                                   ( args -> F            )
                                   args = $pr $line #pos
                                   #I/R #I/A #alph
                                   menu #row attn #parse 
INSERT?                            (  -> flag )
INSERT_MODE                        (  ->  )
(InsertEcho)                       ( $ ->  )
(INSERTN{})                        ( {} ob #n -> {}' )
IntDiv                             A.A/C.A -> A.A=remainder,
                                   C.A=quotient, uses D.A P SB
INTEGER337                         337d 151h
INTEMNOTREF?                       ( ob -> ob flag )
~INTEMPOB?                         ( ob -> ob flag )
(intg)                             ( #0 #0 meta -> meta_ok meta_fail )
(intg1)                            ( M_ok M_fail M_temp meta -> M_ok' M_fail' M_temp )
(intg1fail)                        ( M1 M2 M3 M4 -> M1 M2' M4 T )
(intg1ok)                          ( M1 M2 M3 M4 -> M1' M2 M3 T )
(intgaddlin)                       ( meta #loc -> meta' )
(intgconst)                        ( M_ok M_fail M_temp meta -> M_ok' M_fail' M_temp )
(intglinear)                       ( M1 M2 M3 M4 -> M1' M2 M3 )
intrptderr                         "Interrupted"
xINV                               (    x -> 1/x   )
                                   ( [[]] -> [[]]' )
(InvalServCmd)                     3080d C08h
(INVDEFERR)                        Error 12Ch
(INVFUNCERR)                       Error 103h
INVGROB                            ( grob -> grob' )
(InvLabelGrob)                     21x8 inverse menu key
(INVUNITERR)                       Error B01h
xIP                                ( x -> n )
xISOL                              ( symb var -> symb' )
ISTOP-INDEX                        (  -> # )
ISTOP@                             (  -> # )
ISTOPSTO                           ( # ->  )
IT                                 ( T -> :: <ob1> <rest> ; )
                                   ( F -> :: <ob2> <rest> ; )
ITE                                ( T -> :: <ob1> <ob3> <rest> ; )
                                   ( F -> :: <ob2> <rest> ;       )
ITE_DROP                           ( ob T -> :: <ob2> <rest> ;    )
                                   ( ob F -> :: ob <ob1> <rest> ; )
j%0=case                           ( %0 -> :: <ob1> ;        )
                                   ( ob -> :: <ob2> <rest> ; )
jEQcase                            ( ob1 ob1 -> :: <ob1> ;        )
                                   ( ob1 ob2 -> :: <ob2> <rest> ; )
JINDEX@                            (  -> # )
JINDEXSTO                          ( # ->  )
JstGetTHEMESG                      ( # -> $ )
JstGETTHEMSG                       ( # -> $ )
JSTOP@                             (  -> # )
JSTOPSTO                           ( # ->  )
JUMPBOT                            (  ->  )
JUMPLEFT                           (  ->  )
JUMPRIGHT                          (  ->  )
JUMPTOP                            (  ->  )
KeepUnit                           ( % ob ob' -> % ob  )
                                   (   % ob u -> u' ob )
xKERRM                             (  -> msg )
xKEY                               (  -> rc 1 )
                                   (  -> 0    )
Key>StdKeyOb                       ( #kc #pl -> ob )
Key>U/SKeyOb                       ( #kc #pl -> ob )
KeyInBuff?                         Carry if true
KEYINBUFFER?                       (  -> flag )
xKGET                              (           name ->  )
                                   (         "name" ->  )
                                   (        {names} ->  )
                                   ( {{old new}...} ->  )
xKILL                              (  ->  )
(KILLADISP)                        (  ->  )
KILLGDISP                          (  ->  )
KINVISLF                           ( $ -> $' $'' )
KVIS                               ( $ -> $' )
KVISLF                             ( $ -> $' )
(L%*)                              ( L% L% -> L% )
(L%+)                              ( L% L% -> L% )
(L%-)                              ( L% L% -> L% )
(L%/)                              ( L% L% -> L% )
xLABEL                             (  ->  )
LabelDef!                          ( ob ->  )
lam                                7d 7h
(lam'dvar)                         LAM 'dvar
(LAM>ID)                           ( lam -> id )
(LAM_SKEY)                         LAM SKEY
(larg)                             ( meta -> M_rest M_last )
(larg&)                            ( meta1 meta2 -> meta1&M_rest M_last )
xLAST                              (  -> ob1 .. obn )
                                   UserRPL: xLASTARG
LAST$                              ( $ #start -> $' )
(LASTCMDERR)                       Error 125h
LastMenuDef!                       ( menu ->  )
LastMenuDef@                       (  -> menu )
LastMenuRow!                       ( #n ->  )
LastMenuRow@                       (  -> #n )
LastNonNull                        ( rrp -> ob T )
                                   ( rrp -> F    )
LASTRAM-WORD                       ( rrp -> ob T )
                                   ( rrp -> F    )
(LASTSTKERR)                       Error 124h
xLCD>                              (  -> grob )
                                   UserRPL: xLCD->
(^LEDispItem)                      ( # ->  )
(^LEDispList)                      (  ->  )
(^LEDispPrompt)                    (  ->  )
LEFTCOL                            (  -> #x )
LEN$                               ( $ -> #length )
(LEN$>%)                           ( $ -> % )
LENCOMP                            ( comp -> #n )
(LENCOMP>%)                        ( comp -> %n )
LENHXS                             ( hxs -> #nibs )
(LIB>#)                            ( lib -> #libnum T )
xLIBS                              (  -> {title nlib nport ...} )
xLINE                              (     (x1,y1) (x2,y2) ->  )
                                   ( {#n1 #m1} {#n2 #m2} ->  )
(linear)                           ( meta #level -> meta #loc flag )
(linear!)                          ( meta #level -> meta' flag )
(linear?)                          ( meta #level -> meta' T      )
                                   ( meta #level -> meta' #loc F )
(LINECOUNT)                        Display line counter
                                   [LC3 LC2 LC1 LC0]
                                   and miscellaneous
                                   [DA19 M32 LC5 LC4]
(LineGrob)                         131x2 line
LINEOFF                            ( #x1 #y1 #x2 #y2 ->  )
LINEOFF3                           ( #x1 #y1 #x2 #y2 ->  )
(LINEOFFS)                         3 nibble offset for display
                                   write-only
LINEON                             ( #x1 #y1 #x2 #y2 ->  )
LINEON3                            ( #x1 #y1 #x2 #y2 ->  )
xLINFIT                            (  ->  )
list                               5d 5h
xLIST>                             ( {} -> ob1...obn n )
                                   UserRPL: xLIST->
LISTCMP                            82d 52h
LISTLAM                            87d 57h
(LISTLISTOB)                       1360d 550h
LISTRCL                            ( {path id} -> ob )
LISTREAL                           81d 51h
(LISTREALOB)                       1296d 510h
(LISTREALREAL)                     1297d 511h
liteslp                            Puts calc into "lite sleep"
                                   Low power mode with display on
                                   Wakeup on any key or interrupt
(LiteSlp)                          (  ->  )
xLN                                ( x -> x' )
xLNP1                              ( x -> x' )
LoadTouchTbl                       ( MenuKey1 .. MenuKeyN #n ->  )
(Lock?)                            (  -> flag )
LockAlpha                          (  ->  )
xLOG                               ( x -> x' )
xLOGFIT                            (  ->  )
Lookup                             ( ob test comp -> nextob T )
                                   ( ob test comp -> ob F     )
Lookup.1                           ( ob test -> nextob T )
                                   ( ob test -> ob F     )
                                   Return Stack:
                                   (    comp ->          )
LOOP                               (  ->  )
lowbaterr                          "Low Battery"
xLR                                (  -> Intercept Slope )
(M-1potcase)                       Meta&-1&^ ? case
M-1stcasechs                       (   Meta&NEG -> Meta COLA        )
                                   (       Meta -> Meta SKIP        )
                                   ( Meta&(%<0) -> Meta&ABS(%) COLA )
(M1st*case)                        Meta&* ? case
(M1st+?Drp)                        ( meta&+ -> meta )
(M1st+case)                        Meta&+ ? case
(M1st-case)                        Meta&- ? case
(M1st/case)                        Meta&/ ? case
(M1st^case)                        Meta&^ ? case
(M1stFNCcase)                      Meta&FNCAPPLY ? case
(M1stINVcase)                      Meta&INV ? case
(M1stNEGcase)                      Meta&NEG ? case
(M1stSQcase)                       Meta&SQ ? case
MAKE$                              Creates character string in
                                   tempob area Does SETHEX,
                                   C=C+C.A and then <see>MAKE$N
MAKE$N                             Creates character string in
                                   tempob area If not enough mem
                                   even after GC then memerr
                                   C.A = nibbles -> A=nibbles+5,
                                   B=nibbles+16 C=D1=addr of stack
                                   D0 = addr of body of $
                                   R0 = addr of $  Not used: R1-R4
MAKEARRY                           ( {#n #m} ob -> [] )
makebeep                           C = msec, D = Hz
                                   Checks BEEP flag.
MakeBoxLabel                       ( $ -> grob )
MakeDirLabel                       ( $ -> grob )
makegrob                           R0.A = x, R1.A = y
                                   --> D0 = body
                                   Makes a grob of size x,y
                                   Prolog is in D0-20
MAKEGROB                           ( #height #width -> grob )
MAKEHXS                            ( #nibs -> hxs )
MakeInvLabel                       ( $ -> grob )
MakeLabel                          ( $ #w #x grob -> grob' )
MakeLabel                          ( $ #w #x grob -> grob' )
MAKEPICT#                          ( #w #h ->  )
MAKEPVARS                          (  -> {} )
(MAKERRP)                          ( #libnum -> rrp )
MakeStdLabel                       ( $ -> grob )
xMANT                              ( x -> x' )
MARKGROB                           (  -> grob )
(MAT*)                             ( [F%] [F%]' -> [F%]'' )
(MAT+)                             ( [F%] [F%]' -> [F%]'' )
(MAT-)                             ( [F%] [F%]' -> [F%]'' )
(MAT/)                             ( [F%] [F%]' -> [F%]'' )
(MATABS)                           ( [F%] -> F% )
(MATC>R)                           ( [C%] -> [%re] [%im] )
xMATCHDN                           (       symb {spat srepl} -> symb' 0/1 )
                                   ( symb {spat srepl scond} -> symb' 0/1 )
                                   UserRPL: xMATCH
matchob?                           ( ob comp -> T    )
                                   ( ob comp -> ob F )
xMATCHUP                           (       symb {spat srepl} -> symb' 0/1 )
                                   ( symb {spat srepl scond} -> symb' 0/1 )
                                   UserRPL: x^MATCH
(MATCNRM)                          ( [F%] -> F% )
MATCON                             (   [%] % -> [%]'  )
                                   ( [C%] C% -> [C%]' )
(MATCONJ)                          ( [F%] -> [F%]' )
(MATCROSS)                         ( [F%] [F%]' -> [F%]'' )
(MATDET)                           ( [F%] -> F% )
(MATDOT)                           ( [F%] [F%]' -> F% )
(MATFLOAT*)                        ( [F%] F% -> [F%]' )
(MATFLOAT/)                        ( [F%] F% -> [F%]' )
(MATIDN)                           ( [F%] -> [F%]' )
(MATIM)                            ( [F%] -> [%im] )
(MATINV)                           ( [F%] -> [F%]' )
(MATNEG)                           ( [F%] -> [F%]' )
(MATR>C)                           ( [%re] [%im] -> [C%] )
(MATRE)                            ( [F%] -> [%re] )
MATREDIM                           ( [F%] {#n #m} -> [F%]' )
(MATRND)                           ( [F%] % -> [F%]' )
(MATRSD)                           ( [F%] [F%] [F%] -> [F%] )
(MATSQ)                            ( [F%] -> [F%]' )
MATTRN                             ( [F%] -> [F%]' )
(MATTRNC)                          ( [F%] % -> [F%]' )
xMAX                               ( x y -> x' )
xMAXR                              (  -> MAXR )
xMAXSIGMA                          (  -> xmax      )
                                   (  -> [x1...xn] )
                                   UserRPL: xMAXä
(MBox/StdLbl:)                     (  -> grob )
MDIMS                              ( [1D] -> #m F    )
                                   ( [2D] -> #m #n T )
MDIMSDROP                          ( [2D] -> #m #n )
xMEAN                              (  -> xmean     )
                                   (  -> [x1...xn] )
MediumCursor                       (  -> grob )
xMEM                               (  -> x )
MEM                                (  -> # )
MEMERR                             1d 1h
(MEMSKIP)                          ( ob -> #nextaddress )
xMENU                              ( % ->  )
(MENUADDR)                         Menu display start addr
                                   write-only
MenuDef@                           (  -> menu )
MenuExitAct!                       ( ob ->  )
MenuKey                            (  ->  )
MenuKeyLS!                         ( ob -> ob )
MenuKeyNS!                         ( og -> ob )
MenuKeyNS@                         (  -> ob )
MenuKeyRS!                         ( ob -> ob )
MenuMaker                          (  -> ob )
MENUOFF                            (  ->  )
MENUOFF?                           (  -> flag )
MenuRow!                           ( #n ->  )
MenuRow@                           (  -> #n )
MenuRowAct!                        ( ob ->  )
MEQ1stcase                         ( meta&ob1 ob2 -> ob1=ob2 ? case )
MEQopscase                         ( meta1&ob1 meta2&ob2 ob3 ->  )
(MEQU?)                            ( meta1 meta2 -> meta1 meta2 flag )
(MERGE)                            ( #port ->  )
(Meta(()))                         parenthesise nearest term
(Meta(<-)                          include left term
(meta*)                            ( meta&INV -> meta&/ )
(Meta*1)                           mult by one
(meta+)                            ( meta&NEG -> meta&- )
(Meta+1-1)                         add 1 subtract 1
(meta-)                            ( meta&NEG -> meta&+ )
(Meta-())                          double negate & remove prefix
(Meta->())                         remove prefix
(Meta->()C%)                       remove 1st RE,IM; CONJ
(Meta->))                          include right term
(Meta->DEF)                        define function
(Meta->TRG)                        change EXP to trig. fns.
(meta/)                            ( meta&INV -> meta&* )
(Meta1/)                           div by one
(Meta1/())                         double invert & remove prefix
(Meta<-->)                         commute terms
(Meta<-A)                          associate left term
(Meta<-D)                          delete left term
(Meta<-D!)                         delete left term
(Meta<-M)                          merge common factor on left
(Meta<-T)                          move nearest right term to left
(Meta^1)                           pow by one
(MetaA->)                          associate right term
(MetaAF)                           add fractions
(MetaConcase)                      ( meta -> meta )
(MetaD->)                          delete right term
(MetaDINV)                         double invert
(MetaDNEG)                         double negate
(MetaE())                          ( EXP(a)^b -> EXP(a*b) )
(MetaE^)                           ( EXP(a*b) -> EXP(a)^b )
(metainv)                          ( meta&INV -> meta     )
                                   (     meta -> meta&INV )
(metainvlft)                       ( meta -> meta' )
(MetaL())                          ( b*LN(a) -> LN(a^b) )
(MetaL*)                           ( LN(a^b) -> b*LN(a) )
(MetaLess?)                        ( meta1 meta2 -> meta1 meta2 flag )
(MetaM->)                          merge common factor on right
(MetaMore?)                        ( meta1 meta2 -> meta1 meta2 flag )
(metaneg)                          ( meta&NEG -> meta     )
                                   (     meta -> meta&NEG )
(metaneglft)                       ( meta -> meta' )
(MetaRCOLCT)                       restricted collection
metaROTDUP                         ( meta1 meta2 meta3 -> meta2 meta3 meta1 meta1 )
(MetaT->)                          move nearest left term to right
metatail                           ( ob1..obn-i..obn #i #n+1 -> ob1..ob..obn-i #n-i obn-i+1..obn #i )
(MetaTRG*)                         expand trig fns. of a sum
(MetaUnCalc)                       ( meta ob -> LAM3 #1 )
METREDIM                           ( [F%] {#n #m} -> [F%]' )
Mid1stcase                         ( meta&ob -> ob is id )
                                   lam ? case
xMIN                               ( x y -> x' )
xMINR                              (  -> MINR )
xMINSIGMA                          (  -> xmin      )
                                   (  -> [x1...xn] )
                                   UserRPL: xMINä
MINUSONE                           1048575d FFFFFh
(MISLIBERR)                        Error 12Dh
xMOD                               ( x y -> x' )
Modifier                           (  ->  )
ModifierKey?                       ( #kc #pl -> flag )
MOVEDOWN                           Copy downwards C.A nibbles from
                                   D0 to D1, D0 and D1 will point
                                   to the next locations
                                   Used: A.W C.A P
                                   Use this to move upwards
MOVEDSD                            Open a block above stack
                                   A.A=end C.A=nibbles
                                   Adjusts all refs, then <see>ADJMEM
                                   Uses A.W B.A C.10 D.10 D0 D1 P
MOVEDSU                            Delete a block above stack
                                   A.A=start C.A=nibbles
                                   Adjusts all refs, then <see>ADJMEM
                                   Uses A.W B.A C.10 D.10 D0 D1 P
MOVERSD                            Delete a block below RSK
                                   A.A=end C.A=nibbles
                                   Adjusts all refs, then <see>ADJMEM
                                   Uses A.W B.A C.W D.10 D0 D1 P
MOVERSU                            Open a block below RSK
                                   A.A=start C.A=nibbles
                                   Adjusts all refs, then <see>ADJMEM
                                   Uses A.W B.A C.10 D.10 D0 D1 P
MOVEUP                             Copy upwards C.A nibbles from
                                   D0 to D1
                                   D0 D1 will point to start of
                                   area
                                   Used: A.W C.A P
                                   Use this to move downwards
MPY                                Multiply A.W and C.W (-> A.W=C.W)
                                   Uses D.W, SB. Returns carry clear
~MsgBoxMenu                        (  -> {} )
MUL#                               B.A = A.A*C.A
MULTF                              x=x*y
(MYRAMROMPAIR)                     ( rrp -> rrp' T )
                                   ( rrp -> F      )
N+1DROP                            ( ob 1..n #n ->  )
N+1DROP                            ( ob 1..n #n ->  )
(N+1roll)                          ( META1..METAn+1 #n -> META2..METAn+1 META1 )
(N+1unroll)                        ( META1..METAn+1 #n -> METAn+1 META1..METAn )
(NAppKeyOK?)                       (  -> flag )
NcaseSIZEERR                       ( T -> :: <ob> <rest> ; )
                                   ( F -> :: SIZEERR ;     )
NcaseTYPEERR                       ( T -> :: <ob1> <rest> ; )
                                   ( F -> :: TYPEERR ;      )
nCustomMenu                        (  ->  )
NDROP                              ( meta ->  )
NDROP                              ( 1..n #n ->  )
NDROPFALSE                         ( meta -> F )
NDROPFALSE                         ( ob1..obn #n -> F )
NDUP                               ( 1..n #n -> 1..n 1..n )
NDUPN                              ( ob #n -> ob..ob #n )
                                   ( ob #0 -> #0        )
xNEG                               ( x -> x' )
(NEGFLOWERR)                       Error 302h
negunferr                          "Negative Underflow"
NEWLINE$                           "\0a"
NEWLINE$&$                         ( $ -> "$\0a" )
NEWLINE&$                          ( $ -> "$\0a" )
xNEWOB                             ( ob -> ob )
xNEXT                              (  ->  )
NEXTCOMPOB                         ( comp #ofs -> comp #ofs' ob T )
                                   ( comp #ofs -> comp F          )
NEXTLIBBAK                         ( #addr -> backup/library #nextaddr )
(NEXTROMPID)                       ( #libnum -> #nextlibnum T )
                                   ( #libnum -> F             )
NINE                               9d 9h
NINETEEN                           19d 13h
nmetasyms                          ( meta -> meta )
~nNullBind                         ( obn..ob1 #n ->  )
(NOALARMERR)                       Error D04h
(NoAppError!)                      (  ->  )
NoAttn?Semi                        (  ->  )
NOBLINK                            (  ->  )
NoEdit?case                        (  -> :: <ob1> <rest> ; )
                                   (  -> :: <rest> ;       )
NoEditLine?                        (  -> flag )
(NOEQERR)                          Error 104h
NoExitAction                       (  ->  )
nohalt                             (  -> ob )
NOHALTERR                          Error 126h
(NoIdsInMeta?)                     ( meta -> meta flag )
nonopcase                          ( seco -> :: seco <ob2> <rest> ; )
                                   (   ob -> :: ob <ob1> ;          )
(NonUsrKeyOK?)                     (  -> flag )
NOP                                (  ->  )
(NoRollDA2?)                       (  -> flag )
xNOT                               ( x -> x' )
NOT                                ( flag -> flag' )
(NOT$)                             ( $1 $2 -> $' )
NOT?DROP                           ( ob T -> :: ob <ob1> <rest> ; )
                                   ( ob F -> :: <ob1> <rest> ;    )
NOT?GOTO                           ( flag ->  )
NOT?SEMI                           ( T -> :: <ob1> <rest> ; )
                                   ( F -> :: ;              )
NOT?SWAPDROP                       ( ob1 ob2 T -> :: ob2 <ob1> <rest> ; )
                                   ( ob1 ob2 F -> :: ob1 <ob1> <rest> ; )
NOT_IT                             ( T -> :: <ob2> <rest> ; )
                                   ( F -> :: <ob1> <rest> ; )
NOT_UNTIL                          ( flag ->  )
NOT_WHILE                          ( flag ->  )
NOTAND                             ( flag1 flag2 -> flag )
NOTcase                            ( T -> :: <ob2> <rest> ; )
                                   ( F -> :: <ob1> ;        )
NOTcase2DROP                       ( ob1 ob2 T -> :: ob1 ob2 <ob1> <rest> ; )
                                   ( ob1 ob2 F -> :: ;                      )
NOTcase2drop                       ( ob1 ob2 T -> :: ob1 ob2 <ob2> <rest> ; )
                                   ( ob1 ob2 F -> :: <ob1> ;                )
NOTcasedrop                        ( ob T -> :: ob <ob2> <rest> ; )
                                   ( ob F -> :: <ob1> ;           )
NOTcaseDROP                        ( ob T -> :: ob <ob1> <rest> ; )
                                   ( ob F -> :: ;                 )
NOTcaseFALSE                       ( T -> :: <ob1> <rest> ; )
                                   ( F -> F                 )
NOTcaseTRUE                        ( T -> :: <ob1> <rest> ; )
                                   ( F -> T                 )
(NOTCONST?)                        (  -> flag )
NOTcsdrpfls                        ( ob T -> :: ob <ob1> <rest> ; )
                                   ( ob F -> F                    )
(NOTINHARDROM?)                    ( ob -> ob flag )
NOTLISTcase                        ( {} -> :: {} <ob2> <rest> ; )
                                   ( ob -> :: ob <ob1> ;        )
(NOTNUM?)                          (  -> flag )
(NOTREF?)                          ( ob -> ob flag )
NOTROMPcase                        ( romp -> :: romp <ob2> <rest> ; )
                                   (   ob -> :: ob <ob1> ;          )
NOTSECOcase                        ( seco -> :: seco <ob2> <rest> ; )
                                   (   ob -> :: ob <ob1> ;          )
xNOVAL                             (  ->  )
nscknum2                           ( % sym -> symf )
xnsgeneral                         ( meta -> LAM3&meta&LAM1 )
xNSIGMA                            (  -> nrows )
                                   UserRPL: xNä
(NTH@LAM)                          ( lam #n -> ob T )
                                   ( lam #n -> F    )
NTHCOMDDUP                         ( comp #i -> ob ob )
NTHCOMPDROP                        ( comp #i -> ob )
NTHELCOMP                          ( comp #i -> ob T )
                                   ( comp #i -> F    )
NTHOF                              ( ob comp -> #i )
                                   ( ob comp -> #0 )
NULL$                              ""
NULL$?                             ( ob -> flag )
NULL$SWAP                          ( ob -> $ ob )
NULL$TEMP                          (  -> $ )
NULL::                             (  -> :: ; )
(NULLCHARERR)                      Error 102h
NULLCOMP?                          ( comp -> flag )
NULLHXS                            HXS 0
(NULLHXS?)                         ( hxs -> flag )
NULLID                             (  -> id )
NULLLAM                            (  -> lam )
NullMenuKey                        (  ->  )
(NullMenuLbl)                      21x8 normal menu key
(NULLPAINT)                        (  -> grob )
(NULLSYMB)                         (  -> sym )
NULL{}                             (  -> {} )
nultrior                           ( NULL$ -> :: ;                    )
                                   (     $ -> :: $ <Ob1> <Rest> ;     )
xNUM                               ( $ -> n )
num-1=case                         ( -1 -> :: -1 <ob1> ;        )
                                   ( ob -> :: ob <ob2> <rest> ; )
num0=case                          (  0 -> :: 0 <ob1> ;         )
                                   ( ob -> :: ob <ob2> <rest> ; )
num1=case                          (  1 -> :: 1 <ob1> ;         )
                                   ( ob -> :: ob <ob2> <rest> ; )
num2=case                          (  2 -> :: 2 <ob1> ;         )
                                   ( ob -> :: ob <ob2> <rest> ; )
numb1stcase                        ( %/C%/[]/[L] -> :: <ob1> ;      )
                                   (          ob -> :: ob2 <rest> ; )
(NumbMode)                         (  -> # )
(NUMINTEG)                         ( symf QN symf_lo symf_hi -> % )
(NXTPOT%)                          ( % -> flag %' T )
                                   ( % -> % F       )
Ob>Seco                            ( ob -> :: ob ; )
ObEdit                             ( ob -> ob' T )
                                   ( ob -> F     )
(ObInMeta?)                        ( meta ob -> meta ob flag )
xOBJ>                              ( ob -> ? )
                                   UserRPL: xOBJ->
OCRC                               ( ob -> #nib hxs )
OCRC%                              ( ob -> hxs %bytes )
xOCT                               (  ->  )
xOFF                               (  ->  )
OFFSRRP                            ( # ->  )
ofloerr                            "Overflow"
ONE                                1d 1h
ONE#>                              ( # -> flag )
ONE_DO                             ( #stop ->  )
(ONE_DO_ARRY)                      ( [] -> [] )
ONE_EQ                             ( # -> flag )
ONECOLA                            Does ONE, then COLA.
ONEDUP                             (  -> #1 #1 )
ONEFALSE                           (  -> #1 F )
ONEFALSE'                          (  -> #1 F nob )
ONEHUNDRED                         100d 64h
ONEONE                             (  -> #1 #1 )
(ONEPOS$)                          ( $ $find/chr -> #pos )
ONESWAP                            ( ob -> #1 ob )
(ONESYMBN)                         ( ob1..obn #n -> symb )
ONE{}N                             ( ob -> { ob } )
OnKeyDown?                         Carry if true
OnKeyStable?                       Carry if true
(ONSRRP?)                          ( # -> flag )
xOPENIO                            (  ->  )
OR                                 ( flag1 flag2 -> flag )
xOR                                ( x y -> x' )
OR$                                ( $ $' -> $'' )
ORcase                             ( f1 f2 -> :: <ob1> ;        )
                                   ( f1 f2 -> :: <ob2> <rest> ; )
xORDER                             ( {names} ->  )
ORDERXY#                           ( #x1 #y1 #x2 #y2 -> #x1' #y1' #x2' #y2' )
ORDERXY%                           ( %x1 %y1 %x2 %y2 -> %x1' %y1' %x2' %y2' )
ORNOT                              ( flag1 flag2 -> flag )
OSIZE                              ( ob -> # )
OVER                               ( 1 2 -> 1 2 1 )
xOVER                              ( 1 2 -> 1 2 1 )
OVER#+                             ( # #' -> # #'+# )
OVER#-                             ( # #' -> # #'-# )
OVER#0=                            ( # #' -> # #' flag )
OVER#2+UNROL                       ( meta ob -> ob meta )
OVER#2+UNROLL                      ( 1..n #n ob -> ob 1..n #n )
OVER#<                             ( # #' -> # flag )
OVER#=                             ( # #' -> # flag )
OVER#=case                         ( #m #n -> :: #m <ob1> ;        )
                                   ( #m #n -> :: #m <ob2> <rest> ; )
OVER#>                             ( # #' -> # flag )
(over&)                            ( meta1 meta2 meta3 -> meta1&meta2 meta3 )
OVER'                              ( ob1 ob2 -> ob1 ob2 ob1 nob )
OVER5PICK                          ( 1 2 3 4 -> 1 2 3 4 3 1 )
OVERARSIZE                         ( [] ob -> [] ob #elts )
OVERDUP                            ( 1 2 -> 1 2 1 1 )
(overev&)                          ( meta1 meta2 meta3 -> meta2&meta1 meta3 )
(OVERFLOWERR)                      Error 303h
OVERINDEX@                         ( ob1 ob2 -> ob1 ob2 ob1 # )
OVERLEN$                           ( $ ob -> $ ob #len )
OVERSWAP                           ( 1 2 -> 1 1 2 )
OVERSWAP                           ( 1 2 -> 1 1 2 )
OVERUNROT                          ( 1 2 -> 1 1 2 )
OVERUNROT                          ( 1 2 -> 1 1 2 )
OverWrFLoop                        OverWr FALSE, Loop
OverWrT/FLp                        OverWr TRUE/FALSE, Loop
OverWrTLoop                        OverWr TRUE, Loop
(P::N)                             ( ob1..obn #n -> seco )
PACK                               ( x -> A )
                                   <see>PACKSB without rounding
PACKSB                             ( x -> A )
                                   Converts %% to %.If SB is clear
                                   uses roundup, if set uses
                                   lowest nibble in % field to
                                   determine rounding direction.
                                   Obeys and sets flow
                                   flags/indicators
palparse                           ( $ -> ob T        )
                                   ( $ -> $ #pos $' F )
palrompdcmp                        ( romptr -> $ T )
xPARAMETRIC                        (  ->  )
(parameval)                        ( sym param -> ? )
(parg&)                            ( meta1 meta2 -> meta1&M_last M_rest )
(pargop)                           ( meta -> M_last&op M_rest )
xPARITY                            ( n ->  )
ParOuterLoop                       ( Disp Keys NonAppKeys? DoStdKeys? menu #row suspendOK? ExitCond AppErr ->  )
ParseFail                          ( ob $parsed #pos $' ->  )
xPATH                              (  -> {HOME dir1 .. dirn} )
PATHDIR                            (  -> {HOME dir1 dir2..} )
xPDIM                              ( (xmin,ymin) (xmax,ymax) ->  )
                                   (          #width #height ->  )
xPERM                              ( n k -> n' )
xPGDIR                             ( name ->  )
(PgUserKeys)                       (  ->  )
xPI                                (  -> ã )
                                   UserRPL: xã
PI/180                             ã/180
PICK                               ( 1..n #n -> 1..n 1 )
xPICK                              ( 1...n n -> 1..n 1 )
(pick1)                            ( ob meta -> ob meta ob )
(pick1#0=case)                     ( #0 M -> COLA )
                                   ( ob M -> SKIP )
xPICT                              (  -> PICT )
PICTRCL                            ( xPICT -> grob )
xPIX?                              (   (x,y) -> 1/0 )
                                   ( {#n #m} -> 1/0 )
PIXOFF                             ( #x #y ->  )
xPIXOFF                            (   (x,y) ->  )
                                   ( {#n #m} ->  )
PIXOFF3                            ( #x #y ->  )
PIXON                              ( #x #y ->  )
xPIXON                             (   (x,y) ->  )
                                   ( {#n #m} ->  )
PIXON3                             ( #x #y ->  )
PIXON?                             ( #x #y -> flag )
PIXON?3                            ( #x #y -> flag )
xPKT                               ( data type -> response )
plDRPpZparg                        ( meta&ob -> M_last M_rest )
xPMAX                              ( (x,y) ->  )
xPMIN                              ( (x,y) ->  )
xPOLAR                             (  ->  )
(POLKeyErr)                        (  ->  )
POLKeyUI                           (  ->  )
POLRestoreUI                       (  ->  )
POLResUI&Err                       (  ->  )
POLSaveUI                          ( Disp Keys NonAppKeys? DoStdKeys? menu #row suspendOK? ExitCond AppErr ->  )
(POLSet&KeyUI)                     <see>ParOuterLoop
POLSetUI                           <see>ParOuterLoop
POP#                               Pop # to A.A
POP1%                              ( %pop -> A ) Pop %, <see>SAVPTR
POP1%SPLITA                        ( %pop -> x ) Pop %,
                                   convert to %%, <see>SAVPTR
POP2#                              ( #1 #2 --> )
                                   Pop #1 to A.A and #2 to C.A
POP2%                              ( %pop1 %pop2 -> A,C )
                                   Pop 2 reals, <see>SAVPTR
(POP2HXS)                          Pop hxs to C and hxs to A,
                                   <see>SAVPTR , Clear Carry
                                   P has current wordsize.
PopASavptr                         Pop to A.A, <see>SAVPTR
(POPC%)                            ( C%pop -> A:C ) Pop C%
                                   (<see>SETDEC )
(POPC%%)                           ( C%%pop -> A:B C:D)
                                   Pop C%% (<see>SETDEC )
popflag                            Pop to A.A,
                                   if TRUE then set carry
(POPHXS)                           Pop hxs to A, <see>SAVPTR ,
                                   Clear Carry
POPKEY                             ( -> C.A ) Sets carry if buffer
                                   is empty.Else returns key in
                                   C.B (and in @KEYSTORE)
                                   Uses: A.S C.S C.A D1 (sets P=0)
PopSavptr                          Pop <see>SAVPTR
(PORTEND)                          ( #port -> #addr )
portnotaverr                       "Port Not Avaliable"
PORTSTATUS                         ( #port -> present? writeable? merged? #size #addr )
xPOS                               ( str substring -> n/0 )
                                   (         {} ob -> n/0 )
POS$                               ( $ $find start# -> #pos )
POS$REV                            ( $ $find #limit -> #pos )
POSCHR                             ( $search chr #start -> #pos )
POSCHRREV                          ( $seach chr #start -> #pos )
POSCOMP                            ( comp ob pred -> #i )
                                   ( comp ob pred -> #0 )
                                   (eg: pred = ' %<)
(POSFLOWERR)                       Error 301h
posunferr                          "Positive Underflow"
(POWERCTRL)                        Low power detection
(POWERSTATUS)                      Low power registers
xPR1                               ( ob -> ob )
xPREDIV                            ( x y -> x/y )
                                   UserRPL: xRATIO
xPREDV                             ( x -> y )
xPREDX                             ( y -> x )
xPREDY                             ( x -> y )
PrevNonNull                        ( ob -> ob' T )
                                   ( ob -> F     )
PREVRAM-WORD                       ( ob -> ob' T )
                                   ( ob -> F     )
PrgmEntry?                         (  -> flag )
xPRLCD                             (  ->  )
(PROGIDCMP)                        2146d 862h
(PROGIDEXT)                        2158d 86Eh
(PROGIDLIST)                       2149d 865h
(PROGIDREAL)                       2145d 861h
xPROMPT                            ( $ ->  )
PromptIdUtil                       ( id ob -> $ )
(PROTERR)                          3079d C07h
(PRSOL?)                           (  -> flag )
xPRST                              (  ->  )
prtparerr                          "Invalid PRTPAR"
xPRVAR                             (       name ->  )
                                   (    {names} ->  )
                                   ( :port:name ->  )
psh                                ( meta1 meta2 -> meta2 meta1 )
psh&                               ( meta1 meta2 meta3 -> meta1&meta3 meta2 )
psh1&                              ( meta1 meta2 ob -> ob&meta1 meta2 )
psh1&rev                           ( meta1 meta2 ob -> ob&meta1 meta2 )
(psh1&rev2:)                       ( meta1 meta2 -> meta1&ob1&ob2 meta2 )
(psh1&rev:)                        ( meta1 meta2 -> meta1&ob meta2 )
psh1top&                           ( meta ob -> ob&meta )
(pshm1)                            ( meta ob -> ob #1 meta )
(pshpullpsh1&)                     ( meta1&ob meta2 -> ob&meta2 meta1 )
pshtop&                            ( meta1 meta2 -> meta2&meta1 )
pshzer                             ( meta -> #0 meta )
pshzerpsharg                       ( meta -> M_last M_rest )
(PSYMBN)                           ( ob1..obn #n -> sym )
(PTR>ID)                           ( ob -> id T )
                                   ( ob -> F    )
(PTR>ROMPTR)                       ( ob -> ROMPTR T )
                                   ( ob -> F        )
(PTRREFD?)                         ( ob -> ob flag )
PuHiddenVar                        ( id ->  )
pull                               ( ob # -> #-1 ob )
pull                               ( meta&ob -> meta ob )
PULLCMPEL                          ( [C%] # -> [C%] C% )
(pulldrop)                         ( meta&ob -> meta )
(pulldroppull)                     ( meta&ob1&ob2 -> meta ob1 )
(PULLEL)                           ( [F%] #n -> [F%] F% )
(PULLEREALEL)                      ( [%] #n -> [%] %% )
(PULLLONGEL)                       ( [F%] #n -> [F%] L% )
pullpsh1&                          ( meta1 meta2&ob -> ob&meta1 meta2 )
(pullpshm1)                        ( meta&ob -> ob #1 meta )
PULLREALEL                         ( [%] # -> [%] % )
pullrev                            ( ob&meta -> meta ob )
(pullrev1&)                        ( meta1 meta2&ob -> meta1&ob meta2 )
puretemp?                          ( [] []' -> [] []' flag )
(PURGALARM%)                       ( % ->  )
PURGE                              ( id ->  )
xPURGE                             (       name ->  )
                                   (    {names} ->  )
                                   ( :port:name ->  )
                                   ( :port:nlib ->  )
PUSH#                              <see>GETPTR , Push R0 as #
PUSH#ALOOP                         <see>GETPTR , Push A as #, Loop
Push#FLoop                         <see>GETPTR , Push R0 as #, Do FALSE
Push#Loop                          <see>SAVPTR , R0=A,
                                   <see>PUSH# , Loop
PUSH#LOOP                          <see>GETPTR , Push R0 as #, Loop
Push#TLoop                         <see>GETPTR , Push R0 as #, Do TRUE
PUSH%                              ( A -> %push )
                                   Push A as %, <see>GETPTR
PUSH%LOOP                          ( A -> %push ) Push A as %,
                                   <see>GETPTRLOOP
PUSH2#                             <see>GETPTR , Push R0 & R1 as #
Push2#aLoop                        <see>GETPTR , Push R0 & A as #, Loop
Push2#Loop                         <see>GETPTR , Push R0 & R1
                                   as #, Loop
PUSHA                              Push A, Loop
(PUSHC%)                           ( A:C -> C%push ) Push C%
(PUSHC%%)                          ( A:B:C:D -> C%%push )
                                   Push C%%
PushF/TLoop                        Push FALSE (CRY)/TRUE, Loop
PushFLoop                          Push FALSE, Loop
(PushFTLp)                         Loop to False/True
PUSHhxs                            Push A.WP as hxs
PUSHhxsLoop                        Push A.WP as hxs, Loop
PushT/F                            Push TRUE (CRY)/FALSE, Loop
PushT/FLoop                        Push TRUE (CRY)/FALSE, Loop
PushTLoop                          Push TRUE, Loop
xPUT                               ( ob pos obj -> ob' )
                                   ob  = [] or [[]] or {} or name
                                   pos = n or {n} or {n m}
PUTCMPEL                           ( [C%] C% # -> [C%]' )
PUTEL                              (   [%] % # -> [%]'  )
                                   ( [C%] C% # -> [C%]' )
xPUTI                              ( ob pos obj -> [] pos' )
                                   ob  = [] or [[]] or {} or name
                                   pos = n or {n} or {n m}
PUTINDEP                           ( ID ->  )
PUTINDEPLIST                       ( {} ->  )
PUTLAM                             ( ob #n ->  )
PUTLIST                            ( ob #i {} -> {}' )
putnibs                            ( hxs hxs ->  )
PUTPTYPE                           ( name ->  )
PUTREALEL                          ( [%] % # -> [%]' )
PUTRES                             ( % ->  )
PUTSCALE                           ( % %' ->  )
PUTXMAX                            ( % ->  )
PUTXMIN                            ( % ->  )
PUTYMAX                            ( % ->  )
PUTYMIN                            ( % ->  )
xPVARS                             ( nport -> {} mem )
xPVIEW                             (   (x,y) ->  )
                                   ( {#n #m} ->  )
xPX>C                              ( {#m #n} -> (x,y) )
                                   UserRPL: xPX->C
pZpargSWAPUn                       ( meta -> M_rest M_last )
P{}N                               ( ob1..obn #n -> {} )
xQUAD                              ( symb var -> symb' )
xQUOTE                             ( ob -> 'ob )
R>                                 (  -> :: )
xR>B                               ( x -> # )
                                   UserRPL: xR->B
xR>C                               ( x y -> (x,y) )
                                   UserRPL: xR->C
xR>D                               ( x -> (180/ã)x )
                                   UserRPL: xR->D
R@                                 (  -> :: )
xRAD                               (  ->  )
RAD?                               (  -> flag )
RADD1                              x=x+1 see <see>RADDF
RADDF                              x=x+y
RAM-WORDNAME                       ( ob -> id )
xRAND                              (  -> x )
RCAB0                              R0 -> A.W
                                   R1 -> B.W 
RCAB2                              R2 -> A.W
                                   R3 -> B.W 
RCCD0                              R0 -> C.W
                                   R1 -> D.W 
RCCD2                              R2 -> C.W
                                   R3 -> D.W 
xRCEQ                              (  -> EQ )
xRCL                               (          var -> x   )
                                   (   :port:nlib -> lib )
                                   (   :port:name -> ob  )
                                   ( :port:{path} -> ob  )
Rcl&Do:                            ( id ->  )
xRCLALARM                          ( n -> {date time action rep} )
(RCLALARM%)                        ( %n -> {} )
(RCLALM)                           ( #n -> {} T )
                                   ( #n -> F    )
xRCLF                              (  -> {#s1 #u1 #s2 #u2} )
RclHiddenVar                       ( id -> ob T )
                                   ( id -> F    )
xRCLKEYS                           (  -> {ob ... key ...} )
xRCLMENU                           (  -> x )
xRCLSIGMA                          (  -> [[]] )
                                   UserRPL: xRCLä
RCLSYSF                            (  -> hxs )
RCLUSERF                           (  -> hxs )
xRCWS                              (  -> n )
xRDM                               (   ob size -> ob' )
                                   ( name size ->     )
                                   ob= [] or [[]]
                                   size = {n} or {n m}
RDROP                              (  ->  )
RDROPCOLA                          (  ->  )
(RDROPCOLATRUE)                    (  -> T )
RDROPFALSE                         (  -> F )
RDUP                               (  ->  )
xRDZ                               ( x ->  )
xRE                                ( (x,y) -> x   )
                                   (    [] -> []' )
Re>C%                              ( %re -> C% )
real                               1d 1h
REALcase                           (  % -> :: <ob1> ;        )
                                   ( ob -> :: <ob2> <rest> ; )
REALEXT                            30d 1Eh
(REALNEGcase)                      ( %<0 -> :: % <ob1> ;         )
                                   (  ob -> :: ob <ob2> <rest> ; )
REALOB                             16d 10h
REALOBOB                           256d 100h
REALREAL                           17d 11h
(REALREALOB)                       272d 110h
(REALSTRSTR)                       307d 133h
REALSYM                            26d 1Ah
RECLAIMDISP                        (  ->  )
xRECN                              (  name ->  )
                                   ( $name ->  )
xRECV                              (  ->  )
(REDISPHBUFF)                      (  ->  )
(REFERENCED?)                      ( ob -> ob flag )
(REMOVEN{})                        ( {} #n -> {}' )
xREPEAT                            ( 1/0 ->  )
REPEAT                             (  ->  )
REPEATER                           (  ->  )
REPEATERCH                         (  ->  )
REPKEY?                            ( #kc -> flag )
xREPL                              ( ob pos new -> ob' )
                                   ob= [[]] or [] or {} or $ or PICT
                                   pos= N or {n m} or (n,m)
(repl%-1)                          ( meta&ob -> meta&%-1 )
(repl%1)                           ( meta&ob -> meta&%1 )
(repl*)                            ( meta&ob -> meta&* )
(Repl-1)                           ( meta -> %-1 #1 )
(repl/)                            ( meta&ob -> meta&/ )
(Repl0)                            ( meta -> %0 #0 )
(Repl0ABND)                        ( meta -> %0 )
(Repl1)                            ( meta -> %1 #1 )
(repl:)                            ( meta&ob -> meta&ob' )
REPLACE                            ( newob oldob -> newob )
(replfunc)                         ( meta&ob -> meta&LAM1 )
REQcase                            ( ob -> :: ob <ob2> ;        )
                                   ( ob -> :: ob <ob3> <rest> ; )
REQcasedrop                        ( ob -> <ob2> ;        )
                                   ( ob -> <ob3> <rest> ; )
xRES                               ( n_int ->  )
RESETDEPTH                         ( ob1..obn obn+1..obx #n -> ob1..obn )
RESOROMP                           (  -> ob )
xRESTORE                           ( :port:name ->  )
(Restore16)                        ( grob ->  )
RestVarRes                         (  ->  )
(Retry)                            3083d C0Bh
(revalcase:)                       ( meta -> ?omeg )
reversym                           ( 1..n #n -> n..1 #n )
ReviewKey!                         ( ob ->  )
(revpull&psh)                      ( meta&ob1 ob2 -> ob1&ob2 meta )
(revpulldrop)                      ( meta&ob1 ob2 -> meta ob2 )
RIGHT$3x6                          ( $ #n -> flag grob )
RIGHTCOL                           (  -> #x )
xRL                                ( # -> #' )
xRLB                               ( # -> #' )
xRND                               ( x n -> x' )
RNDXY                              ( % %places -> %' )
xRNRM                              ( [] -> x )
rNTHELCOMP                         ( romptr #i -> ob T )
                                   ( romptr #i -> F    )
xROLL                              ( 1...n n -> 2...n 1 )
ROLL                               ( 1..n #n -> 2..n 1 )
Roll&Do:                           ( # ->  )
roll2top&                          ( meta1 meta2 meta3 -> meta3 meta1&meta2 )
xROLLD                             ( n ... 1 n -> 1 n...2 )
ROLLDROP                           ( 1..n #n -> 2..n )
ROLLSWAP                           ( 1..n #n -> 2..n-1 1 n )
rolltwotop&                        ( meta1 meta2 meta3 -> meta3 meta1&meta2 )
(ROLL{})                           ( {} -> {}' )
ROM-WORD?                          ( ob -> flag )
ROMPANY                            240d F0h
(ROMPART)                          (    rrp -> {#lib1..#libn} T )
                                   ( ROMPTR -> #libnum          )
(ROMPART>ADDR)                     ( #libnum -> #addr T )
                                   ( #libnum -> F       )
(ROMPARTNAME)                      ( #libnum -> id T )
                                   ( #libnum -> F    )
(ROMPARTSIZE)                      ( #libnum -> #nibbles-10 T )
                                   ( #libnum -> F             )
rompointer                         15d  Fh
(ROMPOLL)                          (  ->  )
ROMPTR>#                           ( ROMPTR -> #lib #cmd )
ROMPTR@                            ( ROMPTR -> ob T )
                                   ( ROMPTR -> F    )
(ROMPTR@NOT)                       ( ROMPTR -> ob F     )
                                   ( ROMPTR -> ROMPTR T )
(ROMPTRDECOMP)                     ( ROMPTR -> id T )
                                   ( ROMPTR -> F    )
(ROMSEC)                           ( ROMPTR -> ? )
ROOM                               -> C.A = @DSKTOP-@RETTOP
                                   Uses A.A D0
xROOT                              (     prog/s var guess -> x )
                                   ( prog/s var {guesses} -> x )
ROT                                ( 1 2 3 -> 2 3 1 )
xROT                               ( 1 2 3 -> 2 3 1 )
(rot)                              ( meta1 meta2 meta3 -> meta2 meta3 meta1 )
ROT#+                              ( # ob #' -> ob #'+# )
ROT#+SWAP                          ( # ob #' -> #'+# ob )
ROT#-                              ( # ob #' -> ob #'-# )
ROT#1+                             ( # ob ob' -> ob ob' #+1 )
ROT#1+UNROT                        ( # ob ob' -> #+1 ob ob' )
ROT+SWAP                           ( # ob #' -> #'+# ob )
ROT2DROP                           ( 1 2 3 -> 2 )
ROT2DROP                           ( 1 2 3 -> 2 )
ROT2DUP                            ( 1 2 3 -> 2 3 1 3 1 )
ROTAND                             ( flag1 ob flag2 -> ob flag )
ROTDROP                            ( 1 2 3 -> 2 3 )
ROTDROPSWAP                        ( 1 2 3 -> 3 2 )
ROTDROPSWAP                        ( 1 2 3 -> 3 2 )
ROTDUP                             ( 1 2 3 -> 2 3 1 1 )
ROTOVER                            ( 1 2 3 -> 2 3 1 3 )
ROTROT2DROP                        ( 1 2 3 -> 3 )
ROTROT2DROP                        ( 1 2 3 -> 3 )
ROTSWAP                            ( 1 2 3 -> 2 1 3 )
(rotswap)                          ( meta1 meta2 meta3 -> meta2 meta1 meta3 )
ROTUntop&                          ( meta1 meta2 meta3 -> meta2 meta3&meta1 )
Rows8-15                           (  -> HBgrob #x1 #y1+8 #x1+131 #y1+16 )
RPIT                               ( T ob -> :: ob <ob1> <rest> ; )
                                   ( F ob -> :: <ob1> <rest> ;    )
RPITE                              ( T ob1 ob2 -> :: ob1 <ob1> <rest> ; )
                                   ( F ob1 ob2 -> ob2 <ob1> <rest> ;    )
xRPN->                             ( ob1 .. obn ->  )
                                   UserRPL: x->
xRR                                ( # -> x' )
xRRB                               ( # -> x' )
(RROLL)                            ( #n ->  )
xRSD                               (     [B] [[A]] [Z] -> []'   )
                                   ( [[B]] [[A]] [[Z]] -> [[]]' )
RSKIP                              (  ->  )
rstfmt1                            (  ->  )
RSUB1                              x=x-1 see <see>RADDF
RSWAP                              (  ->  )
(RSZVDISP)                         (  ->  )
SAFE@                              ( id/lam -> ob T )
                                   ( id/lam -> F    )
SAFE@_HERE                         ( id -> ob F )
                                   ( id -> T    )
(SAFE@NOT)                         ( id -> ob F )
                                   ( id -> T    )
SAFESTO                            ( ob id/lam ->  )
xSAME                              ( ob1 ob2 -> 1/0 )
(Save16)                           (  -> grob )
(SAVEERRN)                         (  ->  )
savefmt1                           (  ->  )
SaveLastEdit                       ( $ ->  )
SaveLastMenu                       (  ->  )
SAVESTACK                          (  ->  )
SaveVarRes                         (  ->  )
SAVPTR                             D0 to RPLTOP
                                   D1 to DSKTOP
                                   B to RETTOP
                                   D to FREETOP
                                   Clear carry
xSBRK                              (  ->  )
xSCALE                             ( xs ys ->  )
xSCATRPLOT                         (  ->  )
xSCI                               ( n ->  )
xSCLSIGMA                          (  ->  )
                                   UserRPL: xSCLä
xSCONJ                             ( name ->  )
(ScreenDn)                         moves stk displ down 1 line
(ScreenDnN)                        ( (#n -> ) moves stk displ down #n lines )
(ScreenUp)                         moves stk displ up 1 line
(ScreenUpN)                        ( (#n -> ) moves stk displ up #n lines )
SCROLLDOWN                         (  ->  )
SCROLLLEFT                         (  ->  )
SCROLLRIGHT                        (  ->  )
SCROLLUP                           (  ->  )
xSDEV                              (  -> xsdev     )
                                   (  -> [x1...xn] )
seco                               8d 8h
Seco>Menu                          ( #col :: ->  )
Seco>Menu                          ( #col :: ->  )
SEMI                               (  ->  )
SEMILOOP                           (  ->  )
xSEND                              (           name ->  )
                                   (        {names} ->  )
                                   ( {{old new}...} ->  )
SENDLIST                           ( {} ->  )
(SENDNAME)                         ( id/lam ->  )
SEP$NL                             ( $ -> $' $'' )
xSERVER                            (  ->  )
SetAlgEntry                        (  ->  )
SetAlphaAnn                        (  ->  )
(SetAppError)                      (  ->  )
SetAppMode                         (  ->  )
SetAppSuspOK                       (  ->  )
setbeep                            ( #ms #Hz ->  )
SETCIRCERR                         Error 129h
(SETCORPORT)                       Error 008h
SetCursor                          (      # ->  )
                                   ( {# #'} ->  )
SetDA123NoCh                       (  ->  )
(SetDA12a3NCh)                     (  ->  )
(SetDA12a3NoCh)                    (  ->  )
SetDA12NoCh                        (  ->  )
SetDA12Temp                        (  ->  )
SetDA13NoCh                        (  ->  )
SetDA1Bad                          (  ->  )
(SetDA1BadT)                       (  -> T )
SetDA1IsStat                       (  ->  )
SetDA1NoCh                         (  ->  )
SetDA1Temp                         (  ->  )
(SetDA1TempF)                      (  ->  )
SetDA1Valid                        (  ->  )
(SetDA1ValidF)                     (  ->  )
SetDA23NoCh                        (  ->  )
SetDA2aBad                         (  ->  )
(SetDA2aBadT)                      (  -> T )
SetDA2aEcho                        (  ->  )
SetDA2aNoCh                        (  ->  )
SetDA2aTemp                        (  ->  )
(SetDA2aTempF)                     (  ->  )
SetDA2aValid                       (  ->  )
(SetDA2aValidF)                    (  ->  )
SetDA2bBad                         (  ->  )
(SetDA2bBadT)                      (  -> T )
(SetDA2bEdit)                      (  ->  )
(SetDA2bIsEdL)                     (  ->  )
SetDA2bNoCh                        (  ->  )
SetDA2bTemp                        (  ->  )
(SetDA2bTempF)                     (  ->  )
SetDA2bValid                       (  ->  )
(SetDA2bValidF)                    (  ->  )
SetDA2Echo                         (  ->  )
SetDA2NoCh                         (  ->  )
SetDA2OKTemp                       (  ->  )
SetDA2Valid                        (  ->  )
SetDA3Bad                          (  ->  )
(SetDA3BadT)                       (  -> T )
SetDA3NoCh                         (  ->  )
SetDA3Temp                         (  ->  )
(SetDA3TempF)                      (  ->  )
SetDA3Valid                        (  ->  )
SetDA3ValidF                       (  ->  )
(SetDAsNoCh)                       (  ->  )
SetDAsTemp                         (  ->  )
(SetDAsValid)                      (  ->  )
xSETDATE                           ( date ->  )
SETDEG                             (  ->  )
(SETDIRRECUR)                      Error 002h
SetDoStdKeys                       (  ->  )
(SETFIRSTC_0)                      (  ->  )
SETGRAD                            (  ->  )
SETHASH                            ( #libnum hxs ->  )
SetHiddenRes                       (  ->  )
(SETINVPPAR)                       Error 12Eh
SetIOPARerr                        Error C12h
SetIOPARerr                        (  ->  )
(SETISOLERR)                       Error 130h
SETIVLERR                          Error 304h
SetKeysNS                          ( ob ->  )
(SETLAMERR)                        Error 003h
(SETLBERR)                         Error 006h
SetLeftAnn                         (  ->  )
(SetLock)                          (  ->  )
SETMEMERR                          Error 001h
(SETMESG)                          ( [$] #libnum ->  )
SetNAppKeyOK                       (  ->  )
(SETNONERAL)                       Error 12Fh
SETNONEXTERR                       Error 204h
SetNoRollDA2                       (  ->  )
(SETNOROOM)                        Error 00Bh
(SETNUM)                           (  ->  )
(SetNUsrKeyOK)                     (  ->  )
(SETOBINUSE)                       Error 009h
(SETPORTNOTAV)                     Error 00Ah
SetPrgmEntry                       (  ->  )
SETRAD                             (  ->  )
SetRebuild                         (  ->  )
SetRightAnn                        (  ->  )
SETROMPERR                         Error 004h
SETSIZEERR                         Error 203h
SetSomeRow                         ( #n ->  )
SETSTACKERR                        Error 201h
(setStdWid)                        (  ->  )
SetSysFlag                         ( # ->  )
SetThisRow                         (  ->  )
xSETTIME                           ( time ->  )
                                   UserRPL: x->TIME
SETTYPEERR                         Error 202h
SetUserFlag                        ( # ->  )
(SETXNONEXT)                       Error 00Ch
SEVEN                              7d 7h
SEVENROLL                          ( 1..7 -> 2..7 1 )
SEVENTEEN                          17d 11h
SEVENTY                            70d 46h
SEVENTYFOUR                        74d 4Ah
SEVENTYNINE                        79d 4Fh
xSF                                ( n ->  )
xSHOW                              (    symb name -> symb' )
                                   ( symb {names} -> symb' )
ShowInvRomp                        (  ->  )
(SHOWLS)                           ( sym {names} -> symf )
Shrink$                            Shrinks a strobj
                                   R0.A=->$ D0=end of $
                                   Uses A.W B.A C.W D.10 D0 D1
Sig?ErrJmp                         ( # ->  )
xSIGMA+                            (       x ->  )
                                   ( x1...xn ->  )
                                   UserRPL: xä+
xSIGMA-                            (  -> x  )
                                   (  -> [] )
                                   UserRPL: xä-
xSIGMACOL                          ( x_col y_col ->  )
                                   UserRPL: xCOLä
xSIGMALINE                         (  -> symb )
                                   UserRPL: xäLINE
xSIGN                              ( x -> x' )
xSIN                               ( x -> x' )
xSINH                              ( x -> x' )
(SINNER)                           ( sym -> meta  )
                                   (  ob -> ob #1 )
(SINNERMETA)                       ( meta -> meta' )
xSINV                              ( name ->  )
SIX                                6d 6h
SIXROLL                            ( 1..6 -> 2..6 1 )
SIXTEEN                            16d 10h
SIXTY                              60d 3Ch
SIXTYEIGHT                         68d 44h
SIXTYFOUR                          64d 40h
SIXTYONE                           61d 3Dh
SIXTYTHREE                         63d 3Fh
SIXTYTWO                           62d 3Eh
SIXUNROLL                          ( 1..6 -> 6 1..5 )
xSIZE                              ( ob -> n     )
                                   ( ob -> {N m} )
SKIP                               Skips 1 obj in the runstream.
skipcola                           Does SKIP, then COLA.
SKIPOB                             Skip object in D0, clears ST1,
                                   clears carry, P=0
                                   --> D0  = addr past object
                                   Uses: A.A C.A P ST1 RSTK2
xSL                                ( # -> #' )
xSLB                               ( # -> #' )
SLOW                               (  ->  )
SmallCursor                        (  -> grob )
sncknum2                           ( sym % -> symf )
xSNEG                              ( name ->  )
xsngeneral                         ( meta -> meta&LAM3&LAM1 )
SolvMenuInit                       (  ->  )
SORTASLOW                          (  ->  )
SPACE$                             " "
SPLITA                             ( A -> x ) Convert % to %%
(splitdown)                        ( meta #n #m -> meta #lowlevel #args+1 )
(SPLITEQ)                          ( sym -> arg1 arg2 )
(SPLITmsg)                         ( #msg -> #error #libnum )
(splitup)                          ( meta #n #m -> meta #level )
SPLTAC                             ( A,C -> x, y )
                                   Convert 2 reals to long reals
xSQ                                ( x -> x' )
xSQRT                              ( x -> x' )
                                   UserRPL: xû
xSR                                ( # -> #' )
xSRB                               ( # -> #' )
xSRECV                             ( n -> $ 0/1 )
SrvcKbdAB                          ( A.W -> ) Sets KEYSTATE and
                                   KEYBUFFER
sscknum2                           ( sym sym -> symf )
xssgneral                          ( meta1 meta2 -> meta1&meta2&LAM1 )
sstDISP                            ( ob ->  )
STAB0                              A.W -> R0
                                   B.W -> R1 
STAB2                              A.W -> R2
                                   B.W -> R3 
xSTART                             ( start finish ->  )
StartMenu                          ( menu #n ->  )
xSTARTVAR                          ( start finish ->  )
                                   UserRPL: xFOR
STATCLST                           (  ->  )
(STATCOL)                          ( % %' ->  )
(STATCORR)                         (  -> % )
(STATCOV)                          (  -> % )
STATMEAN                           (  -> %  )
                                   (  -> [] )
STATN                              (  -> N )
(STATPREDX)                        ( % -> %' )
(STATPREDY)                        ( % -> %' )
(STATRCL)                          (  -> ob )
STATSADD%                          ( % ->  )
STATSMAX                           (  -> % )
STATSMIN                           (  -> % )
STATSTDEV                          (  -> %  )
                                   (  -> [] )
(STATSTO)                          ( ob ->  )
STATTOT                            (  -> %            )
                                   (  -> []           )
STATVAR                            (  -> %  )
                                   (  -> [] )
(STATX)                            (  -> % )
(STATXCOL)                         ( n ->  )
(STATXX)                           (  -> % )
(STATXY)                           (  -> % )
(STATY)                            (  -> % )
(STATYCOL)                         ( n ->  )
(STATYY)                           (  -> % )
STCD0                              C.W -> R0
                                   B.W -> R1 
STCD2                              C.W -> R2
                                   B.W -> R3 
xSTD                               (  ->  )
Std/BoxLabel                       ( $ flag -> grob )
StdIOPAR                           (  -> {} )
(StdLabelDef)                      ( #col grob ->  )
                                   (    #col $ ->  )
                                   (   #col id ->  )
                                   (   #col :: ->  )
StdMenuKeyLS                       ( {ob-NS ob-LS ob-RS} -> ? )
StdMenuKeyNS                       (               ob-NS -> ? )
                                   ( {ob-NS ob-LS ob-RS} -> ? )
xSTEP                              (    n ->  )
                                   ( symb ->  )
xSTEQ                              ( ob ->  )
xSTIME                             ( x ->  )
stkdecomp$w                        ( ob -> $ )
xSTO                               (       ob name ->  )
                                   ( ob :port:name ->  )
                                   (      lib port ->  )
                                   (  ob 'name(i)' ->  )
STO                                ( ob id/lam ->  )
STO'                               ( ob id/lam -> nob )
xSTO*                              ( ob name ->  )
xSTO+                              ( ob name ->  )
xSTO-                              ( ob name ->  )
xSTO/                              ( ob name ->  )
xSTOALARM                          (                time -> n )
                                   ( {date time act rep} -> n )
(STOALARM%)                        ( %time -> % )
(STOALARMLS)                       ( {} -> % )
(STOALLFcont)                      ( hxs_usr hxs_sys ->  )
STOALM                             ( %date %time acti %rep -> % )
xSTOF                              ( {#s1 #u1 #s2 #u2} ->  )
StoHiddenVar                       ( ob id ->  )
StoIOPAR                           ( {} ->  )
xSTOKEYS                           (     {ob key ...} ->  )
                                   ( {'S' ob key ...} ->  )
                                   (              'S' ->  )
STOLAM                             ( ob lam ->  )
(STOPLOOP)                         (  ->  )
(STOPSIGN!)                        ( rrp ->  )
(STOPSIGN@)                        (  -> rrp )
xSTOSIGMA                          ( ob ->  )
                                   UserRPL: xSTOä
(STOSYSF)                          ( hxs ->  )
(STOUSERF)                         ( hxs ->  )
(StoUserKeypatch)                  ( ob #kc #p ->  )
(StoUserKeys)                      ( {} ->  )
str                                3d 3h
xSTR>                              ( $ -> ob )
                                   UserRPL: xSTR->
Str>Menu                           ( #col $ ->  )
Str>Menu                           ( #col $ ->  )
STRIPTAGS                          ( tagged -> ob )
STRIPTAGSl2                        ( tagged ob' -> ob ob' )
STRLIST                            53d 35h
STRREALREAL                        785d 311h
xSTWS                              ( n ->  )
xSUB                               ( ob start end -> ob' )
                                   ob= [[]], $, {}, grob
                                   start,end = n, {n m}, (n,m)
SUB$                               ( $ #start #end -> $' )
SUB$1#                             ( $ # -> #' )
SUB$SWAP                           ( ob $ # #' -> $' ob )
SUBCOMP                            ( comp #m #n -> comp' )
SUBGROB                            ( grob #x1 #y1 #x2 #y2 -> grob' )
SUBHXS                             ( hxs #m #n -> hxs' )
SubMetaOb                          ( meta #start #end -> meta' )
SubMetaOb1                         ( ob1..obi..obn #n #i #n #i -> ob1..obi #n #i )
xSUM                               ( var n1 n2 symb -> x )
                                   UserRPL: xä
xSUMX                              (  -> xsum )
                                   UserRPL: xäX
xSUMX2                             (  -> xsum )
                                   UserRPL: xäX2
xSUMXY                             (  -> xsum )
                                   UserRPL: xäXY
xSUMY                              (  -> xsum )
                                   UserRPL: xäY
xSUMY2                             (  -> xsum )
                                   UserRPL: xäY2
SuspendOK?                         (  -> flag )
SWAP                               ( 1 2 -> 2 1 )
xSWAP                              ( ob1 ob2 -> ob2 ob1 )
SWAP#-                             ( # #' -> #'-# )
SWAP#1+                            ( # ob -> ob #+1 )
SWAP#1+                            ( meta ob -> meta&ob )
SWAP#1+SWAP                        ( # ob -> #+1 ob )
SWAP#1-                            ( # ob -> ob #-1 )
SWAP#1-SWAP                        ( # ob -> #-1 ob )
SWAP%%/                            ( %% %%' -> %%'' )
SWAP%>C%                           ( %im %re -> C% )
SWAP&$                             ( $ $' -> $'+$ )
SWAP'                              ( ob1 ob2 -> ob2 ob1 nob )
(SWAP2C%%>%%)                      ( C%% C%%' -> %%re %%im %%re' %%im' )
(SWAP2C%>%)                        ( C% C%' -> %re %im %re' %im' )
SWAP2DUP                           ( 1 2 -> 2 1 2 1 )
SWAP3PICK                          ( 1 2 3 -> 1 3 2 1 )
SWAP4PICK                          ( 1 2 3 4 -> 1 2 4 3 1 )
SWAP4ROLL                          ( 1 2 3 4 -> 2 4 3 1 )
(SWAP>HCOMP)                       ( ob comp -> ob+comp )
SWAPCKREF                          ( ob1 ob2 -> ob2 ob1' )
SWAPCOLA                           Does SWAP, then COLA.
(SWAPCOLUMNS)                      ( [] #m #n -> []' #m #n )
SWAPcompSWAP                       ( ob ob' -> ob'' ob' )
SWAPDROP                           ( 1 2 -> 2 )
(SWAPDROP#1-)                      ( ob # -> #-1 )
SWAPDROPDUP                        ( 1 2 -> 2 2 )
(SWAPDROPLOOP)                     ( ob1 ob2 -> ob2 )
SWAPDROPSWAP                       ( 1 2 3 -> 3 1 )
SWAPDROPSWAP                       ( 1 2 3 -> 3 1 )
SWAPDROPTRUE                       ( ob1 ob2 -> ob2 T )
SWAPDUP                            ( 1 2 -> 2 1 1 )
SWAPINCOMP                         ( comp obj -> obj obn..ob1 #n )
SWAPINDEX@                         ( ob1 ob2 -> ob2 ob1 # )
SWAPLOOP                           ( ob1 ob2 -> ob2 ob1 )
SWAPONE                            ( ob ob' -> ob' ob #1 )
SWAPOVER                           ( 1 2 -> 2 1 2 )
SWAPOVER                           ( 1 2 -> 2 1 2 )
SWAPOVER#-                         ( # #' -> #' #-#' )
(swappargunrot)                    ( meta1 meta2 -> M_rest meta2 M_last )
SWAPROT                            ( 1 2 3 -> 3 2 1 )
SWAPROT                            ( 1 2 3 -> 3 2 1 )
SWAPROWS                           ( [] #m #n -> []' #m #n )
SWAPTRUE                           ( ob1 ob2 -> ob2 ob1 T )
SWAPUnDROP                         ( meta1 meta2 -> meta2 ob1..obn )
SWAPUnNDROP                        ( meta1 meta2 -> meta2 )
(SWITCH2FLOATS)                    ( L% L% -> ? )
(SWITCHFLOATS)                     ( B% -> ? )
SWP1+                              ( meta ob -> meta&ob )
SWP1+                              ( meta ob -> meta&ob )
sym                                10d  Ah
(SYM%SUM)                          ( sym sym % ob -> symf )
symb                               9d 9h
Symb>HBuff                         ( symb ->  )
(SYMBCMP)                          146d 92h
SYMBN                              ( ob1..obn #n -> symb )
SYMBN                              ( ob1..obn #n -> sym )
(SYMBN:)                           ( ob1..obn #n -> symb )
SYMBREAL                           145d 91h
(SYMBSYM)                          154d 9Ah
SYMBUNIT                           158d 9Eh
SYMBWHERE                          ( symf QN1 id1..QNn idn #2n+1 -> symf )
(SYMCMPCMP)                        2594d A22h
(SYMCMPREAL)                       2593d A21h
(SYMCMPSYM)                        2602d A2Ah
SYMCOLCT                           ( symf -> symf )
symcomp                            ( ob -> ob' )
(SYMCRUNCH1)                       ( ob -> % )
(SYMCRUNCH2)                       ( ob1 ob2 -> % ob2 )
(SYMDER)                           ( sym sym -> symf )
(SYMDERSTEP)                       ( QN sym -> symf )
(SYMEXPAN)                         ( symf -> symf )
SYMEXT                             174d AEh
SYMID                              166d A6h
(SYMIDCMP)                         2658d A62h
(SYMIDEXT)                         2670d A6Eh
(SYMIDLIST)                        2661d A65h
(SYMIDREAL)                        2657d A61h
(SYMIFTE)                          ( sym symf symf -> symf )
(SYMINTEG)                         ( symf symf symf QN -> symf )
(SYMISOL)                          ( sym id -> symb )
SYMLAM                             167d A7h
(SYMLIST)                          165d A5h
SYMOB                              160d A0h
(SYMQUAD)                          ( sym id -> symf )
SYMREAL                            161d A1h
(SYMREALCMP)                       2578d A12h
(SYMREALREAL)                      2577d A11h
(SYMREALSYM)                       2586d A1Ah
SYMSHOW                            ( sym id/lam -> symf )
(SYMSUM)                           ( sym sym sym ob -> symf )
SYMSYM                             170d AAh
(SYMSYMB)                          169d A9h
(SYMSYMCMP)                        2722d AA2h
(SYMSYMREAL)                       2721d AA1h
(SYMTAYLR)                         ( sym id % -> symf )
(SYMWHERE)                         ( symf {} -> symf )
SYNTAXERR                          Error 106h
Sys@                               ( ID -> ob T )
                                   ( ID -> F    )
SYSCONTEXT                         (  ->  )
SysDisplay                         (  ->  )
xSYSEVAL                           ( # -> ? )
SysITE                             ( #set -> :: <ob1> <ob3> <rest> ; )
                                   ( #clr -> :: <ob2> <rest> ;       )
SysMenuCheck                       (  ->  )
(SYSRRP?)                          ( rrp -> flag )
SYSRRP?                            ( rrp -> flag )
SysSTO                             ( ob ID ->  )
(SYSSTOPSIGN)                      (  ->  )
SysTime                            (  -> hxs )
(TAG>)                             ( tagged -> ob $tag )
TAGGED                             13d  Dh
TAGGEDANY                          208d D0h
TAGOBS                             (      ob $tag -> tagged    )
                                   ( ob.. { $.. } -> tagged... )
(tailpsh)                          ( meta #n -> meta1 meta2 )
TakeOver                           (  ->  )
xTAN                               ( x -> x' )
xTANH                              ( x -> x' )
xTAYLR                             ( symb var n -> symb' )
TempConv                           ???
TEN                                10d  Ah
(TestSysClr)                       ( # -> flag )
TestSysFlag                        ( # -> flag )
(TestUserClr)                      ( # -> flag )
TestUserFlag                       ( # -> flag )
xTEXT                              (  ->  )
xTHEN                              ( 0/1 ->  )
THIRTEEN                           13d  Dh
THIRTY                             30d 1Eh
THIRTYEIGHT                        38d 26h
THIRTYFIVE                         35d 23h
THIRTYFOUR                         34d 22h
THIRTYNINE                         39d 27h
THIRTYONE                          31d 1Fh
THIRTYSEVEN                        37d 25h
THIRTYTHREE                        33d 21h
THIRTYTWO                          32d 20h
THREE                              3d 3h
THREEFIVE                          53d 35h
THREE{}N                           ( ob1 ob2 ob3 -> { ob1 ob2 ob3 } )
xTICKS                             (  -> # )
(Ticks>Date)                       ( hxs -> %date )
(Ticks>Rpt)                        ( hxs -> %rpt )
(Ticks>TOD)                        ( hxs -> %time )
(Ticks>wd$)                        ( hxs -> $weekday )
ticR                               (  -> ob T )
                                   (  -> F    )
xTIME                              (  -> time )
timeouterr                         "Timeout"
TIMER1                             1 nibble timer
                                   decremented 16 times/s
(TIMER1CTRL)                       TIMER1 control
                                   [SRQ WKE INT XTRA]
TIMER2                             8 nibble timer
                                   decremented 8192 times/s
(TIMER2CTRL)                       TIMER2 control
                                   [SRQ WKE INT TRUN]
TIMESTR                            ( %dt %tm -> "dy dt tm" )
TIMESTR                            ( %dt %tm -> "dy dt tm" )
xTLINE                             (     (x1,y1) (x2,y2) ->  )
                                   ( {#n1 #m1} {#n2 #m2} ->  )
xTMENU                             (  % -> [InitMenu%]        )
                                   ( Ob -> [@LIST InitMenu]   )
TOADISP                            (  ->  )
TOD                                (  -> %time )
TOD>t$                             ( %time -> $ )
(TOD>Ticks)                        ( %time -> hxs )
TOGDISP                            (  ->  )
TOGGLELINE#3                       ( #x1 #y1 #x2 #y2 ->  )
TOGLINE                            ( #x1 #y1 #x2 #y2 ->  )
TOGLINE3                           ( #x1 #y1 #x2 #y2 ->  )
(TogSysFlag)                       ( # ->  )
(tok$)                             "$"
(tok&)                             "&"
tok'                               "'"
(tok*)                             "*"
(tok+)                             "+"
tok,                               ","
tok-                               "-"
tok->                              "->"
tok.                               "."
(tok/)                             "/"
tok0                               "0"
tok1                               "1"
(tok2)                             "2"
(tok3)                             "3"
(tok4)                             "4"
(tok5)                             "5"
(tok6)                             "6"
(tok7)                             "7"
tok8                               "8"
tok8cktrior                        ( $1 $1 -> :: $1 <Ob1> ;          )
                                   ( $1 $2 -> :: $1 <Ob2> <Rest> ;   )
tok8trior                          ( GNT data $1 $1 -> :: GNT data GetNextToken ; )
                                   ( GNT data $1 $2 -> :: $1 <Ob1> <Rest> ;       )
tok9                               "9"
(tok;)                             ";"
tok<<                              "®"
tok=                               "="
tok=casedrop                       ( $ $' -> :: <ob1> ;          )
                                   ( $ $' -> :: $ <ob2> <rest> ; )
(tok>>)                            "¯"
(tok[)                             "["
(tok])                             "]"
(tok^)                             "^"
tok_                               " "
tok_g                              "g"
tok_m                              "m"
tok_s                              "s"
(tokanglesign)                     ""
(tokCTGROB)                        "GROB"
(tokCTSTR)                         "C$"
(tokDER)                           "ë"
tokESC                             "\1B"
tokexponent                        "E"
(toklparen)                        "("
tokquote                           """
(tokrparen)                        ")"
toksharp                           "#"
(tokSIGMA)                         "ä"
(tokSQRT)                          "û"
(tokUNKNOWN)                       "UNKNOWN"
(tokuscore)                        "_"
(tokWHERE)                         "|"
tok{                               "{"
(tok})                             "}"
toLEN_DO                           ( {} -> {} )
top&                               ( meta1 meta2 -> meta1&meta2 )
top&Cr                             ( meta1 meta2 -> symb )
(top&pshtop&)                      ( meta1 meta2 meta3 -> meta2&meta3&meta1 )
TOP16                              (  -> HBgrob #x1 #y1 #x1+131 #y1+16 )
TOP8                               (  -> HBgrob #x1 #y #x1+131 #y1+8 )
TOPROW                             (  -> #y )
TOSRRP                             ( # ->  )
xTOT                               (  -> xsum      )
                                   (  -> {x1...xn} )
TOTEMPOB                           ( ob -> ob' )
(TOTEMPOBADJ)                      ( ob -> ob ob' )
TOTEMPSWAP                         ( ob1 ob2 -> ob2' ob1 )
xTRANSIO                           ( n ->  )
TRCXY                              ( % %places -> %' )
xTRN                               ( [[]] -> [[]]' )
                                   ( name ->       )
xTRNC                              ( x n ->  )
TRUE                               (  -> T )
TRUE'                              (  -> T nob )
TrueFalse                          (  -> T F )
TRUEFALSE                          (  -> T F )
TrueTrue                           (  -> T T )
xTRUTH                             (  ->  )
xTSTR                              ( date time -> $ )
TTHIRTYSIX                         36d 24h
TURNMENUOFF                        (  ->  )
TURNMENUON                         (  ->  )
TurnOff                            (  ->  )
xTVARS                             (  ntype -> {} )
                                   ( {n...} -> {} )
TWELVE                             12d  Ch
TWENTY                             20d 14h
TWENTYEIGHT                        28d 1Ch
TWENTYFIVE                         25d 19h
TWENTYFOUR                         24d 18h
TWENTYNINE                         29d 1Dh
TWENTYONE                          21d 15h
TWENTYSEVEN                        27d 1Bh
TWENTYSIX                          26d 1Ah
TWENTYTHREE                        23d 17h
TWENTYTWO                          22d 16h
TWO                                2d 2h
(TWODROPNULL$)                     ( ob ob' -> NULL$ )
TWO{}N                             ( ob1 ob2 -> { ob1 ob2 } )
TYPE                               ( ob -> #prolog )
xTYPE                              ( ob -> %type )
TYPEARRAY?                         ( ob -> flag )
TYPEARRY?                          ( ob -> flag ??? )
(TYPEARRY@)                        ( [] -> # )
TYPEBINT?                          ( ob -> flag )
TYPECARRY?                         ( ob -> flag )
TYPECHAR?                          ( ob -> flag )
(TYPECMP)                          10615d 2977h
TYPECMP?                           ( ob -> flag )
(TYPECOL)                          11677d 2D9Dh
TYPECOL?                           ( ob -> flag )
TYPECSTR?                          ( ob -> flag )
(TYPEEREL)                         10581d 2955h
(TYPEEXT)                          10970d 2ADAh
TYPEEXT?                           ( ob -> flag )
TYPEGROB?                          ( ob -> flag )
TYPEHSTR?                          ( ob -> flag )
TYPEIDNT                           10568d 2948h
TYPEIDNT?                          ( ob -> flag )
(TYPELAM)                          11885d 2E6Dh
TYPELAM?                           ( ob -> flag )
(TYPELIST)                         10868d 2A74h
TYPELIST?                          ( ob -> flag )
TYPERARRY?                         ( ob -> flag )
TYPEREAL                           10547d 2933h
TYPEREAL?                          ( ob -> flag )
TYPEROMP?                          ( ob -> flag )
(TYPERRP)                          10902d 2A96h
TYPERRP?                           ( ob -> flag )
(TYPESYMB)                         10936d 2AB8h
TYPESYMB?                          ( ob -> flag )
TYPETAGGED?                        ( ob -> flag )
U>nbr                              ( u -> % )
U>NCQ                              ( u -> n%% cf%% qhxs )
xUBASE                             ( u -> u' )
xUFACT                             ( u1 u2 -> u3 )
UM#?                               ( u u' -> %flag )
UM%                                ( u %percent -> u' )
UM%CH                              ( u u' -> % )
UM%T                               ( u u' -> % )
UM*                                ( u u' -> u'' )
um*                                * marker
UM+                                ( u u' -> u'' )
UM-                                ( u u' -> u'' )
um/                                / marker
UM/                                ( u u' -> u'' )
UM<=?                              ( u u' -> %flag )
UM<?                               ( u u' -> %flag )
UM=?                               ( u u' -> %flag )
UM>=?                              ( u u' -> %flag )
UM>?                               ( u u' -> %flag )
UM>U                               ( % u -> u' )
um^                                ^ marker
UMABS                              ( u -> u' )
UMCEIL                             ( u -> u' )
UMCHS                              ( u -> u' )
UMCONV                             ( u1 u2 -> u1' )
UMCOS                              ( u -> u' )
umEND                              Unit end operator
(UMFACT)                           ( u1 u2 -> u )
UMFLOOR                            ( u -> u' )
UMFP                               ( u -> u' )
(UMINV)                            ( u -> u' )
UMIP                               ( u -> u' )
UMMAX                              ( u u' -> u? )
UMMIN                              ( u u' -> u? )
(UMOPER:)                          ( u -> u' )
umP                                Char prefix operator
UMRND                              ( u -> u' )
UMSI                               ( u -> u' )
UMSIGN                             ( u -> % )
UMSIN                              ( u -> u' )
UMSQ                               ( u -> u' )
UMSQRT                             ( u -> u' )
UMTAN                              ( u -> u' )
UMTRC                              ( u -> u' )
UMU>                               ( u -> % u' )
UMXROOT                            ( u u' -> u'' )
Unbr>U                             ( u % -> u' )
UNCOERCE                           ( # -> % )
UNCOERCE%%                         ( # -> %% )
UNCOERCE2                          ( # # -> % % )
(UNCOERCE{}2)                      (   {#} -> {%}   )
                                   ( {# #} -> {% %} )
uncrunch                           (  ->  )
undo                               (  ->  )
UNDO_OFF                           (  ->  )
UNDO_ON                            (  ->  )
UNDO_ON?                           (  -> flag )
UNIT>$                             ( u -> $ )
unitob                             14d  Eh
UnLockAlpha                        (  ->  )
UNROLL                             ( 1..n #n -> n 1..n-1 )
UNROT                              ( 1 2 3 -> 3 1 2 )
UNROT                              ( 1 2 3 -> 3 1 2 )
(unrot)                            ( meta1 meta2 meta3 -> meta3 meta1 meta2 )
(unrot1)                           ( meta1 meta2 ob -> ob meta1 meta2 )
UNROT2DROP                         ( 1 2 3 -> 3 )
UNROT2DROP                         ( 1 2 3 -> 3 )
(UNROT2DROP%0)                     ( 1 2 3 -> 3 %0 )
UNROTDROP                          ( 1 2 3 -> 3 1 )
UNROTDROP                          ( 1 2 3 -> 3 1 )
UNROTDUP                           ( 1 2 3 -> 3 1 2 1 )
UNROTOVER                          ( 1 2 3 -> 3 1 2 1 )
UNROTSWAP                          ( 1 2 3 -> 3 2 1 )
UNROTSWAP                          ( 1 2 3 -> 3 2 1 )
UNROTSWAPDROP                      ( 1 2 3 -> 3 2 )
UNTIL                              ( flag ->  )
xUNTIL                             (  ->  )
(UobROT)                           ( ob meta1 meta2 -> meta1 meta2 ob )
xUPDIR                             (  ->  )
UPDIR                              (  ->  )
USER$>TAG                          ( ob $tag -> tagged )
UserITE                            ( #set -> :: <ob1> <ob3> <rest> ; )
                                   ( #clr -> :: <ob2> <rest> ;       )
(UserKeys!)                        ( {} ->  )
UserKeys?                          (  -> flag )
UStackDepth                        (  -> # )
xUTPC                              ( n x -> x' )
xUTPF                              ( n1 n2 x -> x' )
xUTPN                              ( n v x -> x' )
xUTPT                              ( n x -> x' )
xUVAL                              ( u -> x )
xV>                                ( []/() -> x y   )
                                   ( []/() -> x y z )
                                   (in current co-system)
                                   UserRPL: xV->
xVAR                               (  -> x         )
                                   (  -> [x1...xn] )
xVARS                              (  -> {} )
VARSIZE                            ( id -> hxs %bytes )
VerifyTOD                          ( %time -> %time )
VERSTRING                          (  -> $ )
(VERSTRING?)                       ( $ -> $ flag )
VERYSLOW                           (  ->  )
VERYVERYSLOW                       (  ->  )
ViewLevel1                         ( ob -> ob' )
xVTYPE                             ( name -> n )
w->W                               Calculates GROB width
                                   A.A=width in pixels
                                   -> A.A=width in nibbles
xWAIT                              ( sec ->      )
                                   (   0 -> rc.p )
(wait)                             ( hxs ->  )
Wait/GetKey                        ( % -> ? )
WaitForKey                         (  -> #kc #flag )
(WHERE1)                           ( QN1 id1..QNn idn #n meta1 -> symf )
(WHEREN)                           ( QN1 id1..QNn idn #2 metan -> symf )
WHILE                              ( flag ->  )
xWHILE                             (  ->  )
WINDOW#                            ( #x #y ->  )
WINDOWBOT?                         (  -> flag )
WINDOWCORNER                       (  -> #x #y )
WINDOWDOWN                         (  ->  )
WINDOWLEFT                         (  ->  )
WINDOWLEFT?                        (  -> flag )
WINDOWRIGHT                        (  ->  )
WINDOWRIGHT?                       (  -> flag )
WINDOWTOP?                         (  -> flag )
WINDOWUP                           (  ->  )
WINDOWXY                           ( #x #y ->  )
WIPEOUT                            Zeroes C.A nibbles at D1
                                   Uses A.W C.A P
WithHidden                         (  -> ? )
WORDSIZE                           (  -> # )
xWSLOG                             (  -> $ $ $ $ )
(WSLOG)                            (  -> $4 $3 $2 $1 )
(WSLOGN)                           ( #n -> $ )
xXCOL                              ( n ->  )
XEQ>ARRAY                          ( F%..F% {#n #m} -> [F%] )
XEQ>ARRY                           ( F%..F% {#n #m} -> [F%] )
(XEQ>VECTOR)                       ( F%..F% %n -> [%F] )
(XEQAsnKey)                        ( ob %rc.p ->  )
(XEQDelKeys)                       ( {} ->  )
(XEQINTEG)                         ( ob ob ob QN -> symf )
(XEQINTEGID)                       ( ob ob ob id/lam -> symf )
(XEQLIST>)                         ( comp -> obn..ob1 %n )
XEQORDER                           ( {id1 id2..} ->  )
XEQPGDIR                           ( id ->  )
(XEQPOS$)                          ( $ $find/chr -> %pos )
XEQPURGEPICT                       ( xPICT ->  )
XEQRCL                             ( id -> ob )
(XEQRclKeys)                       (  -> {} )
(XEQRCWS)                          (  -> % )
XEQSETLIB                          ( % ->  )
XEQSHOWLS                          ( sym {} -> symf )
XEQSTOID                           ( ob id/lam ->  )
XEQStoKey                          ( ob ID ->  )
(XEQSTWS)                          ( % ->  )
(XEQSUB$)                          ( $ % %' -> $' )
(XEQSYMDERCON)                     ( QN %/C%/u -> symf )
(XEQSYMDERSTEP)                    ( QN sym -> symf )
(XEQSYMWHERE)                      ( symf QN1 id1..QNn idn -> symf )
XEQTYPE                            ( ob -> ob %type )
(XFERFAIL)                         3078d C06h
XHI                                131d 83h
XHI-1                              130d 82h
xXMIT                              ( $ -> 1       )
                                   ( $ -> $rest 0 )
xXOR                               (    # #' -> #'' )
                                   (    $ $' -> $'' )
                                   ( 1/0 1/0 -> 1/0 )
XOR                                ( flag1 flag2 -> flag )
XOR$                               ( $ $' -> $'' )
xXPON                              (    % ->  )
                                   ( symb ->  )
xXRNG                              ( x1 x2 ->  )
xXROOT                             ( y x -> Y' )
XY>Y                               ( 1 2 -> 2 )
XYEX                               A:B <-> C:D
XYGROBDISP                         ( #x #y grob ->  )
XYZ>                               ( 1 2 3 ->  )
XYZ>Y                              ( 1 2 3 -> 2 )
XYZ>Y                              ( 1 2 3 -> 2 )
XYZ>YXZ                            ( 1 2 3 -> 2 1 3 )
XYZ>YZ                             ( 1 2 3 -> 2 3 )
XYZ>Z                              ( 1 2 3 -> 3 )
XYZ>Z                              ( 1 2 3 -> 3 )
XYZ>ZCOLA                          Does UNROT2DROP, then COLA.
XYZ>ZTRUE                          ( ob1 ob2 ob3 -> ob3 T )
XYZ>ZX                             ( 1 2 3 -> 3 1 )
XYZ>ZX                             ( 1 2 3 -> 3 1 )
XYZ>ZXY                            ( 1 2 3 -> 3 1 2 )
XYZ>ZXY                            ( 1 2 3 -> 3 1 2 )
XYZ>ZY                             ( 1 2 3 -> 3 2 )
XYZ>ZY                             ( 1 2 3 -> 3 2 )
XYZ>ZYX                            ( 1 2 3 -> 3 2 1 )
XYZ>ZYX                            ( 1 2 3 -> 3 2 1 )
XYZW>                              ( 1..4 ->  )
XYZW>W                             ( 1 2 3 4 -> 4 )
XYZW>WXYZ                          ( 1 2 3 4 -> 4 1 2 3 )
XYZW>YWZX                          ( 1 2 3 4 -> 2 4 3 1 )
XYZW>YZWX                          ( 1 2 3 4 -> 2 3 4 1 )
xYCOL                              ( n ->  )
YHI                                64d 40h
xYRNG                              ( y1 y2 ->  )
ZERO                               0d 0h
ZERO_DO                            ( #stop ->  )
ZEROFALSE                          (  -> #0 F )
ZEROISTOPSTO                       (  ->  )
ZEROOVER                           ( ob -> ob #0 ob )
ZEROSWAP                           ( ob -> #0 ob )
ZEROZERO                           (  -> #0 #0 )
ZEROZEROONE                        (  -> #0 #0 #1 )
ZEROZEROTWO                        (  -> #0 #0 #2 )
ZEROZEROZERO                       (  -> #0 #0 #0 )
({}>TAG)                           ( { id ob } -> tagged )
{}N                                ( obn..ob1 #n -> { obn..ob1 } )
